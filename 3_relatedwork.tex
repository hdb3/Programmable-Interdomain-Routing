\chapter{Related Work}
The first objective in this chapter is to distinguish the multiple themes that have had an impact on this thesis, while the second is to try to build a coherent narrative linking the development of networking academic thought and research with the parallel developments in the wider world of industry and society.
An interesting aspect of both of these is the extent to which academic discourse has either influenced, or  has been influenced by, the wider, practical, world.
In the first objective, a particular theme is the extent to which academic research is genuinely forward-looking, or is `merely' concerned with current topics - though it is actually not difficult to make the argument that a good deal of academic effort is devoted to solving the problems of yesterday, rather than of tomorrow, or even of today.

\medskip
There is a dearth of recent academic work that closely follows the course of this thesis, but the work considered for the purpose of this chapter was selected using the following criteria:

\begin{itemize}[noitemsep,nolistsep]
	\item{transit ISP or IDR context;}
	\item{real world/practical - non-pure theoretical (but inclusive of simulation or high level outline, e.g, pgBGP);}
	\item{BGP / routing level service quality (inc. availability, security, performance).}
\end{itemize}
\medskip
Topics excluded from detailed review, which may still have an impact, include work on:

\begin{itemize}[noitemsep,nolistsep]
	\item{BGP stability and convergence;}
	\item{Internet measurement and observation;}
	\item{radical, clean-slate `Future Internet' solution.}
\end{itemize}
\smallskip
%Why is there so little recent work of a similar kind?
%Perhaps the advice of Jon Crowcroft in \cite{Crowcroft2009} may have something to do with it:

%\emph{BGP: I actually cannot think of a way to save BGP as a topic. Likewise, ATM.}

%However, Jon then went on to comment more positively on BGP, for example he foresaw the main application for BGPFlowspec (RFC5575)\cite{RFC5575}.

Another contributing factor to the dearth of relevant related work may be a particularly distinctive aspect of this thesis, which is the focus on \emph{non-disruptive} approaches to the problem space:
until recently (circa 2016) the techniques proposed here were not available in production quality network equipment.
So, in reviewing past work, it is useful to consider how the various authors' approaches might have differed had they been working with the capabilities that exist today.
Earlier researchers would surely have considered and possibly followed the path articulated here, had it been available.
%That they did not do so is no reflection on their (apparent lack of) insight. 
%but neither should it be taken as a negative reflection on the approach now proposed.

%It is interesting, however, to note the path by which innovation has been adopted - without disruption - which now enables fresh approaches to old problems.

There are other aspects impacting the problem space that have also changed since earlier work was published, some highlights of which are:
\begin{itemize}[noitemsep,nolistsep]
	\item{the major advances in processor resources deployed in network routing equipment and the changing focus of Internet usage and challenges;}
	\item{scalability and resource constrained stability are less critical -- in its place are increased concerns about security and routing failures, malicious and otherwise;}
	\item{changes in Internet level topology (flattening, IXPs, and the growth of CDNs);}
	\item{changes in ISP internal architectures (MPLS, Route Reflection, AnyCast).}
\end{itemize}

Thus the papers selected and discussed in this chapter have -- in common with this thesis -- a practical intent, both in terms of problem definition and proposed solutions, but the problems, the tools and the technical context may have changed since many of these papers were written.
Also reviewed is more recent work which is closely related, though with different objectives and applications, for example Artemis, iSDX and Google/Facebook SDN.

\section{The RCPs}
The term Routing Control Platform (hereafter RCP) was introduced by Rexford, Feamster, et al in 2004 in their seminal paper     \citetitle{Feamster2004} (\citeauthor{Feamster2004}, \citeyear{Feamster2004})~\cite{Feamster2004}.


This, the most ambitious vision for RCP, was extended in more detail in subsequent work from the same group:

\begin{itemize}
    \item \textbf{RCP2} \citetitle{Caesar2005}\\(\citeauthor{Caesar2005}, \citeyear{Caesar2005})~\cite{Caesar2005}
    \item \textbf{IRSCP1} \citetitle{VanDerMerwe2006}\\(\citeauthor{VanDerMerwe2006}, \citeyear{VanDerMerwe2006})~\cite{VanDerMerwe2006}
    \item \textbf{IRSCP2} \citetitle{Karlin2006}\\(\citeauthor{Karlin2006}, \citeyear{Karlin2006})~\cite{Karlin2006}
    \item \textbf{PGBGP} \citetitle{Verkaik2007}\\(\citeauthor{Verkaik2007}, \citeyear{Verkaik2007})~\cite{Verkaik2007}
\end{itemize}

% \begin{itemize}[noitemsep,nolistsep]
% 	\item{“Design and implementation of a routing control platform” (2005)  \cite{Caesar2005}}
% 	\item{“Dynamic connectivity management with an intelligent route service control point” (2006) \cite{VanDerMerwe2006}}
% 	\item{“Pretty good BGP: Improving BGP by cautiously adopting routes” (2006) \cite{Karlin2006}}
% 	\item{“Wresting Control from BGP : Scalable Fine-grained Route Control” (2007) \cite{Verkaik2007}}
% \end{itemize}

Note that in the later papers, the term Intelligent Route Service Control Point (IRSCP) replaces RCP: they are essentially the same thing.

\bigskip

\textbf{RCP1} \cite{Feamster2004} presents a three stage evolution of a transit ISP network, in which the final state is one in which the routers that make up the network forwarding plane are demoted to a passive role for all BGP operations, while a logically centralised RCP interacts directly with external AS peers, and also exerts direct control over all forwarding paths in every router, using IBGP.
In the final state, the possibility to replace or augment EBGP is proposed: an intermediate state is defined in which the external control plane remains conventional EBGP, albeit EBGP to the RCP rather than EBGP to Border Routers.
RCP1 makes convincing arguments for the benefit accrued at every stage of the evolution, and emphasises the importance of viable intermediate stages with immediate benefits to network operators.
In RCP1, we find that the important motivations for operators of the time were the control over instability and convergence time, rather than routing failures or malicious behaviours.

\bigskip

\textbf{RCP2} \cite{Caesar2005} complements \cite{Feamster2004}: it reports on a concrete implementation of an RCP as described on a theoretical basis in RCP1.
RCP2 details what is described in RCP1 as a `stage 1' RCP, which is a purely internally connected RCP, with correspondingly lower capability than the complete RCP1 vision.
In contrast to RCP1, RCP2 is a practical, implementation focused paper.
However, unlike RCP1, the narrow problem focus in RCP2 is one that has little relevance to today's networks - RCP2 is designed to address limitations in the then current IBGP route reflection architectures.
RCP2 describes a system that builds a complete real-time representation of both the BGP routing state and the IGP (OSPF) routing state, and uses its IGP model to drive optimal IBGP control over every router.
Although only a `stage 1' RCP, RCP2 already isolates every router from its internal neighbours, but it lacks direct external peer connectivity, and so relies on Border Routers advertising their `best' paths to provide the set of available routes for distribution within the AS.
RCP2 reports that the implemented RCP is derived from the open source BGP implementation Quagga.
CPU RAM usage and routing latency is measured, although there is insufficient detail to enable direct comparison with other work. For example, how effective is the implementation for end-to-end path changes to take effect at the overall AS level, in either control-plane or data-plane.
It is noteworthy that RCP2 represents an entirely disruptive implementation model - if the RCP fails to perform satisfactorily there is no fail-safe mechanism, and the RCP is responsible for 100\% of all routing management.
So, although existing router hardware and software is retained, network configuration and topology is radically altered.

\bigskip

\textbf{IRSCP1} \cite{VanDerMerwe2006} is authored by a group at ATT led by J. Van der Merwe, one of the authors in RCP1\&2.
The authors explain how this work extends that in RCP1\&2 and justify the change of name from RCP to IRSCP to explicitly identify the parallel with the telephony systems concept of Intelligent Networking (IN) and the IN concept of a Network Control Point (NCP).
The authors explain that IRSCP extends the work in RCP2 to `enable external information to inform the route selection process, in much the same way that the NCP did for the circuit switched network.'
RSCP1 extends the range of uses for the internally connected `stage 1' RCP described in RCP2.
The use cases described are:
\begin{myitemize}
    \item Selective DDoS Blackholing;
    \item planned Maintenance Dryout;
    \item and Network Aware Load-balancing (a form of TE).
\end{myitemize}
IRSCP1 implements each of these functions by boosting local preference of existing routes, or in the case of selective blackholing, originating new routes with high preference.
The mechanism for this is interesting: at a low level, the implementation is classical BGP router configuration used to manipulate received routes before forwarding to downstream peers. However, the implementation provides a kind of `macro' facility that allows the higher level intention to be specified with commands such as addblackhole/delblackhole or adddryout/deldryout; these commands translate directly into familiar `route-map' configurations in standard Quagga.

\bigskip

\textbf{IRSCP2} \cite{VanDerMerwe2006} barely extends the work in \cite{Caesar2005}, except to show some additional use cases for the `stage 1' RCP prototype. \cite{Verkaik2007} represents a significant further step, again articulated as a concrete, functional implementation.
IRSCP2 describes an implementation of a `stage2' RCP (although the authors do not explicitly use this taxonomy).
In IRSCP2, the `stage2' RCP (henceforth just the IRSCP2) is implemented as a mesh of connected IRSCPs. IRSCPs are connected directly to external AS peers using conventional EBGP: in the BGP plane, the slave BRs are now entirely isolated apart from one-way `command' BGP sessions from the IRSCPs.
As in previous work, the IRSCPs also snoop on IGP state in real-time, but the BRs are the only active participants in the IGP.
IRSCPs are meshed, using an extended version of BGP (much like ADD\_PATH ).
In aggregate, the IRSCPs form a logically centrally controller that holds a complete view of all externally offered routes and runs a customised selection process to determine which routes to distribute to which BRs.
The controller applies internal consistency rules to ensure that it excludes combinations of routes which have loops, blackholes or `deflections', but otherwise the route selection process is driven by an exhaustive ranking matrix that defines for BR and prefix which egress points are preferred.
The IRSCP2 architecture retains a BGP speaker RIB which is at least loosely compliant with RFC4271 route selection rules and processes; the divergence is in the admission of multiple routes to the same prefix into the final stage of route selection, where the per-peer logic is applied.
Conventionally, this stage is a simple binary filter function; IRSCP2 replaces this stage with a `ranking function' that assigns a per-peer custom selection logic listing acceptable egress peers in order.
Only routes to these peers are allowed, and the highest ranked one is disseminated to the BR.
The mechanism for routing control is the updating of these ranks.
IRSCP2 has another interesting change over previous work: it switched to a different BGP speaker, openbgpd, from Quagga.
%NO comment is made on this change!  
The IRSCP2 paper provides some performance data for the implementation, in much fuller detail than the paper RCP2.
They report that the prototype can process 4,200 received BGP Update messages per second when it has 10 downstream peers.

\bigskip

\textbf{PGBGP} \cite{Karlin2006} is a contemporaneous `related' work, cross-referenced with the other papers in this group, and sharing a lead author, J.Rexford.
PGBGP is effectively another use-case for IRSCP2, and referenced as such in IRSCP2, in a similar way that IRSCP1 extends RCP2 with additional use cases.
PGBGP is interesting in that it addresses today's major IDR challenge of `bogus' routes in a holistic way, articulating a practical strategy for detecting and mitigating routing attacks, showing the effectiveness of this strategy at the global level based on varying levels of adoption by transit operators, including an Internet scale simulation.
The paper suggests several implementation strategies, but the one that does not require major changes in existing router software is effectively the `IRSCP', described thus:
\emph{The edge routers would be configured to forward all externally learned routes to the server. In addition to constructing the set of trusted (prefix, origin AS) pairs, the server would apply the PGBGP decision process and send each router a single best route for each prefix. This is possible today by implementing PGBGP on the Routing Control Platform (RCP) described in [27, 28]. This approach would obviate the need for any changes to routers, but would place a larger burden on the server to be fast and reliable.}

\subsection{General discussion on RCP work}
The parallels between the RCP body of work and this thesis are strong. Two common fundamental premises are, first, that management of Internet transit routing cannot be effectively executed by conventional router software or even unmodified software BGP speakers; and, second, that using existing core routers (software and hardware) is the only practical strategy.
The long term vision in RCP of removing routers entirely from the BGP decision process is well aligned with this thesis. However, RCP does not actually address the issue of evolution from the status quo to even the `stage 1' RCP architecture.
Nor does RCP address the tension between the need for rapid routing decision-making to mitigate network failures and the challenge of making more intelligent decisions:  even the most advanced RCP (IRSCP2) is not actually a real-time/online intelligent routing policy engine. By going straight to the `stage 1' architecture, RCPs side-step the complexity (and benefits) of `cooperative' routing, i.e. a hybrid mode in which existing router functionality coexists with override capability as required.
IRSCP2 provides a good overview of the reasons for this disparity of view: \emph{IRSCP maintains complete control of the route selection function for all routers in the network}. As we argue later, this can only be achieved by having IRSCP communicate directly with routers in neighbouring networks via EBGP, in addition to speaking IBGP with the routers in the IRSCP-enabled network.

This gives IRSCP full visibility of all routes available in the network. Further, IRSCP is now the sole controller of BGP route selection, meaning that all of the network's routing policy can be handled by the route control application through IRSCP, as opposed to placing some policy configuration on the routers themselves, as is the case in an IBGP-speaking IRSCP.

Had ADDPATH or BMP been available, or even under discussion at the time of writing, then perhaps this work might have taken a different course, as exemplified by the examples 10 years later of Google and Facebook.
Ironically, the BGP extension devised for IRSCP2 is very similar to ADDPATH.

\section{Morpheus}
Jennifer Rexford and others authored three papers between 2007 and 2009 under the `Morpheus' banner:
\begin{itemize}[noitemsep,nolistsep]

	\item{2007: Wang, Y., Avramopoulos, I.,  Rexford, J. \cite{Wang2007}.\\`Morpheus: Making routing programmable.' Proceedings of the 2007 SIGCOMM Workshop on Internet Network Management, INM ’07}
	\item{2009: Wang, Y., Avramopoulos, I.,  Rexford, J. \cite{Wang2009}.
	            \\`Design for configurability: Rethinking interdomain routing policies from the ground up.' IEEE Journal on Selected Areas in Communications, 27(3)}
	\item{Rexford, J.,  Feigenbaum, J. \cite{Rexford2009}.
	            \\`Incrementally-deployable security for interdomain routing.' Proceedings - Cybersecurity Applications and Technology Conference for Homeland Security.}
\end{itemize}

\smallskip
The 2007 paper introduces Morpheus as an architecture; the first 2009 paper restates the same principles augmented by an implementation, while the third repackages Rexford's \cite{Karlin2006} as a Morpheus policy component.


The Morpheus prospectus is to expose the route diversity available to a large ISP to its downstream customers.
The mechanism proposed is to provide a policy specification system that can be applied centrally and in multiple instances. Different policy specifications lead to different choices of routes; downstream customers subscribe to any one of the policy instances which have been defined, potentially as many policies as there are customers.
The ability to use multiple distinct paths to specific destinations is enabled by tunnelling in the ISP core, e.g. MPLS, and by the use of Virtual Routers (VRFs) at customer facing Border Routers.
The mechanism by which the Morpheus servers gain access to routes is through the complete diversion of external peer BGP sessions to Morpheus, away from the ISP Border Routers: IBGP is used to populate the forwarding table for customer facing routers.
A novel contribution in Morpheus is an augmented route selection algorithm that allows multiple concerns to be factored into selection outcomes: each factor is evaluated by a customisable domain specific algorithm, and a weighted aggregation function applied to the individual outputs to generate a linear ranking value
\subsection{Analysis and Comparison with PIR}
Morpheus has as a central theme in its prospectus a very similar proposition to this thesis, which is that route selection policy should be opened up to more programmability and control than is currently possible.
However, it differs in several essential aspects:
the concrete outcome of deploying Morpheus is that different downstream customers will route traffic over different routes, whereas the proposition of this thesis is that there is a single view of ‘worst’ routes, which should be avoided for all purposes, rather than multiple different views of ‘best’ routes.
(A corollary of this assertion is that as far as objectives are concerned, this thesis complements Morpheus - however, see later more detailed discussion on this point.)

The ‘target user’ for Morpheus is subtly different: Morpheus implicitly addresses Internet end-users (eyeballs or content), rather than ISPs. This difference underlies the proposition that customer priorities may differ sufficiently to justify routing user traffic to the same destination over different paths. (ISPs have to worry about the concerns of all of their customers.)
In contrast, an ISP's priorities are much simpler: the most profitable (cheapest) route that meets explicit and implicit SLAs is always preferred, and the implied or explicit SLAs are essentially common.
\\
Unlike PIR\footnote{PIR (Programmable Internet Routing) is the generic name for the core software implementation work in this thesis}, Morpheus is a centralised / clean slate / disruptive architecture, in the same mould as earlier RCP work. 
%%% \textcolor{red}{[DH: Does PIR need re-stated here ..?]}
%%% \NH{in the foot note a good solution?}
\\
Morpheus makes no attempt at delivering or measuring overall routing performance: and while the 2009 paper shows an evolution from a single Morpheus server to a cluster, there is no discussion on the subject of how the Morpheus server functions can be distributed over a cluster of machines.
The performance issue Morpheus does address is the feasibility of executing the extended route selection process within time intervals consistent with current routing performance. However, the routing performance is not adequate to handle typical bursts or routing, unless a very high degree of parallel processing is implemented; a rough estimate is that it is a factor of 100x slower than current production software routers, even in a small topology.
The authors' defence is that this is an `unoptimised’ implementation.
Like PIR, Morpheus allows route selection processes to access ‘side information’ - examples include historical databases of AS paths, and measured performance data such as RTTs. However, the design requires any ‘side information’ to be immediately available, as opposed to enabling asynchronous/offline processes to respond to new routes.
That is, once a ‘bad’ route has passed initial review it is not capable of subsequent demotion.
In this regard Morpheus is a retrograde step from the IRSCP.

%\textcolor{red}{DH: edited up to here now ...}

\subsection{Evaluation}
Value proposition - Morpheus stands or falls on the basis that for an ISP there are routes with significant traffic for which alternate paths exist, and for which there are disparate customer groups for whom different paths would be materially better.
This is a much harder test than merely one route having a higher aggregate score under one weighting than another - for Morpheus to add value for a single destination case, the following scenario must hold:

\begin{itemize}
    \item the route has multiple customers with substantial traffic;
    \item there are multiple viable alternate paths;
    \item collectively, these paths are capable of meeting all customer requirements;
    \item no one path simultaneously meets all minimum customer requirements;
    \item and so the only way to satisfy all customers is to diversely route them.
\end{itemize}

Additionally, there must be a sufficient number of such routes, and willing customers, to warrant the implementation of a complex system like Morpheus, to cover the extra costs incurred in deploying and supporting Morpheus.
Whether in 2009 there were many Internet customers with the specialist requirements and degree of sophistication needed to appreciate this offer is hard to know - but in today's environment the priority is more likely to be security and protection from DDoS and routing attacks - and for this network providers with global reach do exist, but since that offer does not demand multiple different trade-offs, the complexity of Morpheus is not required.
A final shortcoming for Morpheus is the problem of asymmetric routing: Morpheus might enable outbound traffic to be optimally and diversely routed, but it does nothing for inbound traffic - and for services mentioned, such as VoIP, the return path is as important as the outbound.
\subsection{Conclusion}
Morpheus complements (complemented) the transit network optimisation proposition of this thesis - and by adopting the disruptive centralised model of the RCP it avoids the complexity challenge of coexistence and compatibility with existing architectures.
In contrast, this thesis proposition is that improved IDR is principally a problem of better rejection of bad routes, rather than nuanced distinction between multiple viable routes.
And unlike this work, Morpheus, as a proof-of-concept, does not seek to address the scaling challenges of large scale network deployment.

\section{``Neighbor-Speciﬁc BGP'', and RFC9087}

\subsection{``Neighbor-Speciﬁc BGP''}

\begin{itemize}
    \item \citetitle{Wang2009a}\\(\citeauthor{Wang2009a}, \citeyear{Wang2009a})~\cite{Wang2009a}
\end{itemize}

% \emph{Neighbor-Speciﬁc BGP: More Flexible Routing Policies While Improving Global Stability} \cite{Wang2009a}
is another paper from the Rexford school, published in 2009.  The paper could easily have been fitted into the Morpheus review section, given the contemporaneity and intersection of the topic.  But the choice was made to separate it, because it represents, in many ways, a first step towards the `clean' end-goal architecture solution for PIR, the subject of this thesis.

\textbf{Neighbour-Speciﬁc BGP: The Paper} is a largely theoretical analysis, which aims to prove that Neighbor-Speciﬁc BGP: The System is not a threat to general routing stability.  Here, we pass no comment on the argument or rigour of the argument (though, in fact, it seems rather unconvincing).  But the gem nestling in this paper is in the section `Deployment', and the subsections 5.1 Neighbor-Speciﬁc Forwarding and 5.2 Route Dissemination Within an AS.


\textbf{5.1 Neighbour-Speciﬁc Forwarding} proposes the use of MPLS to enable a single egress ASBR to simultaneously forward traffic to more than one connected EBGP peer, based on the selection of the ingress ASBR; MPLS provides for tunnels, so that packets with the same destination address can be forwarded to different paths even though arriving at the same ingress port within the AS.


\textbf{5.2 Route Dissemination Within an AS} explains how the ASBR can discover that these distinct egress paths exist, and in theory, how to use them.
It is noteworthy that the protocol and protocol usage described in this paper in 2009, ADDPATH, was not actually published until 7 years later, as RFC7911 \cite{rfc7911} (2016). (The first draft - draft-ietf-idr-add-paths-00.txt - is dated December 2008.)


Another small obstacle in the way of implementation for this paper is that, until RFC8277 \cite{rfc8277}  (`Using BGP to Bind MPLS Labels to Address Prefixes') from 2018, there was no practical forwarding plane addressing mechanism to realise the proposal. The paper merely mentions `MPLS-VPNs', which were supported by BGP since early on, but they used only indirect methods of allowing BGP and MPLS to operate in synergy - there was no explicit signalling of anything specific to MPLS, just the use of opaque Route Discriminators - effectively just VRF labels.

Sadly, perhaps, commercial implementation lags specification by even more than specification lags these works of Jennifer Rexford.  Today (2025), there is still no known hardware vendor with general release software\footnote{Juniper JUNOS supports many elements as described in the next section; however, a complete scalable solution for IDR is not available from this vendor, or any other, as far as it is possible to determine.} that supports a usable control plane strategy for implementing \emph{Neighbor-Speciﬁc BGP} - it will possibly be 20 years between conception and implementation.

The final note, which may partly explain the slowness in commercial implementation, is that there appears to be (in this author's opinion), some missing aspects that would enable scalable implementations of Neighbor-Speciﬁc BGP: the issue is the choice of MPLS end-to-end forwarding architecture - and, indeed, the question as to whether MPLS or SRv6 would be a better solution, or both.
The scalability problem is that the load on an MPLS control plane, when egress node selection is enabled, becomes rather high: in the baseline, the number of pre-built MPLS paths is proportional to just the number of ASBRs, with some solutions to reduce the $N^2$ scale problem for larger topologies.  But, if every ASBR advertises every peer, then the $N^2$ factor is now N=no of external peer links, rather than N-no of ASBRs.  Source routing (segment routing) can obviously reduce the scaling threat, but unfortunately, there was, until recently, no defined scheme (viz. RFC) for mapping ADDPATH advertised prefixes to segmented-routed paths. 


\subsection{RFC9087 - and other Related, Recent IETF work}

\begin{itemize}
    \item \textbf{RFC9087} \citetitle{rfc9087} (\citeyear{rfc9087})~\cite{rfc9087}
    \item \textbf{RFC7855} \citetitle{rfc7855} (\citeyear{rfc7855})~\cite{rfc7855}
\end{itemize}

Within IETF, the `Routing Area' functional areas are the working groups \textit{IDR Inter-Domain Routing} and  \textit{Source Packet Routing in Networking (SPRING)}, which have both produced highly relevant material.

Spring was chartered in 2016, and RFC7855 is the `Source Packet Routing in Networking (SPRING) Problem Statement and Requirements'.

RFC7855 contains the statements:
\begin{quote}
       The SPRING architecture MUST allow an ingress node (i.e., an explicit
   route source node) to select the exit point of a packet as any
   combination of an egress node, an egress interface, a peering
   neighbor, and a peering AS.

   The use cases and requirements for egress peer engineering are
   described in [SR-BGP-EPE].
\end{quote}
[SR-BGP-EPE] points towards what would eventually become the 2021 RFC9087, `Segment Routing Centralized BGP Egress Peer Engineering'\cite{rfc9087}, which somewhat recursively points back to RFC7855 for the definition of BGP Egress Peer Engineering.  Directly related is RFC9086 `Border Gateway Protocol - Link State (BGP-LS) Extensions for Segment Routing BGP Egress Peer Engineering'.  RFC9086 is dated August 2021 and is from the IDR WG, not SPRING.

In summary, \emph{BGP Egress Peer Engineering} appears to be almost exactly \emph{Neighbor-Speciﬁc BGP}, albeit defined in just one sentence, plus a recursive loop between two RFCs. 

Then, RFC9087, `Segment Routing Centralized BGP Egress Peer Engineering'\cite{rfc9087}  is a protocol specification for an implementation of \emph{Neighbor-Speciﬁc BGP}.  However, rather than advocate for ADDPATH, as in RFC7911+RFC8277, as the solution for joining the MPLS domain and the BGP managed external prefix reachability, RFC9087 advocates RFC9086 `Border Gateway Protocol - Link State (BGP-LS) ..', which was RFC7752 (March 2016), now RFC9552 (December 2023), as the basis for correlating the BGP and MPLS addressable endpoints associated with prefixes.

Rising above the level of RFC `soup', there is a clear strategy between the IDR and SPRING WGs to implement something very much like \emph{Neighbor-Speciﬁc BGP} with a centralised controller. To quote from the introduction of RFC9087:
\begin{quote}
    1.1.  Problem Statement

   The BGP-EPE problem statement is defined in [RFC7855].

   A centralized controller should be able to instruct an ingress
   Provider Edge (PE) router or a content source within the domain to
   use a specific egress PE and a specific external interface/neighbour
   to reach a particular destination.

   Let's call this solution ``BGP-EPE" for ``BGP Egress Peer Engineering".
   The centralized controller is called the ``BGP-EPE controller".  The
   egress border router where the BGP-EPE traffic steering functionality
   is implemented is called a BGP-EPE-enabled border router.  The input
   policy programmed at an ingress border router or at a source host is
   called a BGP-EPE policy.
\end{quote}

RFC9087 goes on to say:
\begin{quote}
      The definition of the BGP-EPE controller is outside the scope of this document.

\end{quote}

and 
   \begin{quote}
     Section 5 overviews the methods that could be used by the centralized BGP-EPE controller to implement a BGP-EPE policy at an ingress border router or at a source host within the domain.  The exhaustive definition of all the means to program a BGP-EPE input policy is outside the scope of this document.
\end{quote}

Interestingly, nowhere to be found is the specific suggestion that ``BGP Egress Peer Engineering" or ``Neighbor-Speciﬁc BGP" could be used for the purpose of making a transit ISP more secure.

\subsubsection{Summary - RFC9087}
There is some vendor adoption of the new SPRING+IDR ideas, for example, in current Juniper JUNOS, there is declared support for all of the protocol elements of RFC7855 and  RFC9085/6/7.   However, this is only part of a solution - there is still no clear candidate for a controller, nor is there even a clear mechanism for operating the ingress ASBR in some hybrid mode that would allow for default IBGP behaviours of route selection based on conventional IBGP schemes - i.e., LocalPreference.

It is possible to consider `controller-free' high level schemes in general terms, but not so easy when restricted to the normal BGP configuration schemes. For example, a `policy rule' might install a forwarding entry for traffic from an ASBR to a prefix, or selected traffic from an ASBR to a prefix, but unless the ingress ASBR itself runs a BGP-LS session with every egress ASBR candidate, there can be no decentralised logic that would reroute traffic in the event of the route state changing at the selected ASBR, or at any other.  And even if there were a full distribution of BGP-LS state between all ASBRs, there is still no simple way to encode exception rules that `make sense'.  

The naive solution does work:
at each ASBR in `ingress mode', assemble in the `AdjRibIn' every potential path, for every prefix, and use a local policy scheme to calculate, for every downstream peer of the ingress ASBR, what path of all offered upstream ASBRs should be chosen.  Clearly, existing policy language (`route maps') can easily be extended to allow this - the problems it introduces are first scale - discounting for a moment Route Reflectors, the size of routing state and required CPU resource to operate it increases from $ N_{ASBRs}^2 $ to $ N_{external\ peers}^2 $.

\paragraph{A Role for Route Reflectors?}
Of course, discounting Route Reflectors is not obviously the right thing to do - but, other than by reducing the load on BGP-LS sources (egress mode ASBRs), it is hard to propose a role for Route Reflectors that is not much more invasive than the simplistic one for which they are defined. In particular, a Route Reflector runs `best path' and thereby reduces options available to clients, but in the model where specific clients are enabled explicitly to make their own diverse selection, the Route Reflector has no role - if it eliminates path options then it disables ``BGP Egress Peer Engineering".  The only thing that makes sense is if the Route Reflector itself is responsible for ``BGP Egress Peer Engineering".


Once an expanded role for Route Reflectors is proposed, it is clear that such an enhanced Route Reflector is simply an instance of the RFC9087 ``centralized BGP-EPE controller".



\subsection{Summary - Neighbor-Speciﬁc BGP and RFC9087}\label{Neighbor-Speciﬁc BGP and RFC9087}

The timelines may seem incoherent - Neighbor-Speciﬁc BGP was published in 2009, but references IETF publications formalised in 2016; while  those same IETF publications in 2016 (RFC7911/ADDPATH) also point forward, to RFC8277 (Using BGP to Bind MPLS Labels to Address Prefixes), which is seen now effectively a development dead-end, as far as ``Egress Peer Engineering" is concerned, while already BGP-LS existed in 2016, and eventually emerged as the winner over ADDPATH, at least in this context.

BGP-LS - RFC7752/March 2016 - eventually adapted as a basis for the SR-MPLS forwarding plane solution of RFC9087 (2021), is extended to do so, also in 2021, as RCF9086: ``(BGP-LS) Extensions for Segment Routing BGP Egress Peer Engineering".

The outcome is perhaps not surprising: ADDPATH was far too ambiguous to be relied upon - perhaps the relevant question is why BGP-LS was chosen rather than BMP.  However, this is immaterial - the conclusion is clear, that IETF and vendors have adapted and extended the MPLS and SR-MPLS forwarding plane\footnote{or the MPLS evil twin, SRv6}, which is the only credible strategy for enabling more diverse forwarding than AS-wide best-path using IGP, as not only the (AS Internal) Traffic Engineering forwarding plane but the ``Egress Peer Engineering" solution too.  This is hardly surprising, since ``Egress Peer Engineering" is really just the logical and extreme extension of general ``TE".

In fact, were ``Neighbor-Speciﬁc BGP" to be written today, the proposal of ADDPATH+MPLS as the solution elements would, without question, be rewritten as simply RFC908{5,6,7}.
\\
Unfortunately, there is still no clear picture of an architecture for controllers that can help solve the issues of avoiding routing attacks dynamically, without throwing out completely the existing distributed best path model of conventional IBGP.

And it is worth pointing out that for all its complexity and maturity, MPLS-TE as implemented in effectively every large transit ISP\footnote{Ideally, a source reference is needed for this claim.  There exist many tutorials and presentations in e.g. NANOG, that presuppose this, but harder evidence is not easy to find.}, still works with the same IBGP+RR external path management scheme.

The topic of how an appropriate controller can be built, and how it should interact with ASBRs, is a central issue in this thesis, and the current section aims to highlight prior work and context, with their associated uncertainties.


If there are any deductions that can be made at this stage -- for long term viable solutions for live networks -- they are as follows:
\begin{itemize}
    \item for route state monitoring, the preferred solution is BGP-LS;
    \item for flexible and diverse forwarding plane management, the preferred solution is SR-MPLS (or SRv6).
\end{itemize}

A conclusion might therefore be: the Internet architecture evolves very slowly -- most often by adapting and extending accepted designs.  While BGP-LS and SR-MPLS were `in the air' in 2009, it may be 2029 before they `hit the ground' as a solution for the challenges of either ``Neighbor-Speciﬁc BGP", or ``PIR/BGP Protection", which are the core themes of this thesis.


\section{SDX}

% \textcolor{red}{
This section provides a significant contrast in approach to that of the previous section -- it starts from a different perspective, one in which Software Defined Networking (SDN) is seen as an opportunity to improve BGP routing prospects by applying SDN to Internet Exchange Points (IXPs).
% }
% \NH{i think its a proposed text, happy to accept if that's right understanding}

\subsection{Origins}
\emph{The `Princeton Papers'}
The following is the complete list from the Princeton SDX publications page: \url{https://sdx.cs.princeton.edu/publications.html}.

\begin{itemize}
    \item \fullciteinfo{feamster2013}
    
    \footnote{at the time of writing these resources were all available, however by 2025 both the Princeton University summary of SDX and also record of the ONS presentation in 2013 are no longer available online.  There is still a record of a presentation given by Nick Feamster at IETF86 in March 2013 with the same title `SDX: A Software-Defined	Internet Exchange' - see \url{https://www.ietf.org/proceedings/86/slides/slides-86-sdnrg-6.pdf}.  The Princeton summary page can still be found in The Internet Archive.}
  
    \item \fullciteinfo{Gupta2014}
    \item \fullciteinfo{Gupta2016}
    \item \fullciteinfo{Gupta2016a}
    \item \fullciteinfo{Birkner2017}
\end{itemize}


% \begin{itemize}[noitemsep,nolistsep]
% \item{SDX: A Software Defined Internet Exchange~\cite{feamster2013}\footnote{at the time of writing these resources were all available, however by 2025 both the Princeton university summary of SDX and also record of the ONS presentation in 2013 are no longer available online.  There is still a record of a presentation given by Nick Feamster at IETF86 in March 2013 with the same title `SDX: A Software-Defined	Internet Exchange' - see \url{https://www.ietf.org/proceedings/86/slides/slides-86-sdnrg-6.pdf}.  The Princeton summary page can still be found in The Internet Archive.}\\
% 	{\footnotesize Nick Feamster, Jennifer Rexford, Scott Shenker, Dave Levin, Russ Clark, Ron Hutchins, Josh Bailey\\
% 	Open Networking Summit, Santa Clara, CA. April 2013.}}

% \item{SDX: A Software Defined Internet Exchange ~\cite{Gupta2014}\\
% 	{\footnotesize Arpit Gupta, Laurent Vanbever, Muhammad Shahbaz, Sean P. Donovan, Brandon Schlinker, Nick Feamster, Jennifer Rexford, Scott Shenker, Russ Clark, Ethan Katz-Bassett\\
% 	ACM SIGCOMM, Chicago, IL. August 2014.}}

% \item{iSDX: An Industrial-Scale Software Defined Internet Exchange Point~\cite{Gupta2016}\\
% 	{\footnotesize Arpit Gupta, Robert MacDavid, Rüdiger Birkner, Marco Canini, Nick Feamster, Jennifer Rexford, Laurent Vanbever\\
% 	USENIX NSDI, Santa Clara, CA. March 2016.}}

% \item{Authorizing Network Control at Software Defined Internet Exchange Points~\cite{Gupta2016a}\\
% 	{\footnotesize Arpit Gupta, Nick Feamster, Laurent Vanbever\\
% 	SOSR, Santa Clara, CA. March 2016.}}  
    
% \item{SDX-Based Flexibility or Internet Correctness? Pick Two!~\cite{Birkner2017}\\
% 	{\footnotesize Rüdiger Birkner, Arpit Gupta, Nick Feamster, Laurent Vanbever\\
% 	ACM SOSR, Santa Clara, CA. April 2017.}}


% \end{itemize}

\smallskip

SDX was and remains an ambiguous term, but it is clear that the generally accepted scope and vision have changed since its initial coinage.
Here, `SDXes' is used to denote the general class of architectures, of which Princeton SDX was the first example.


The ambiguity makes it difficult to position SDX precisely in relation to the work of this thesis.
One consistent strand of SDX, however, is a role for classical OpenFlow style data-plane SDN, which sets it apart from the thesis work.
Also, the application context of SDX, the IXP, while related, is distinct from the focus of this thesis, which is the transit ISP, but the technical challenges, strategies and solution architectures overlap substantially.
Depending on the objective, solutions from one domain may even translate directly to the other.


This review and analysis of SDX literature finds much of the early SDX work overly ambitious in its goals, and not well aligned with IXP and ISP operational models or business objectives.   Indeed, a sceptic might conclude that SDX was more an outlet for the SDN / OpenFlow bandwagon, which was still in search for compelling applications for the new technology, rather than being a response to well-defined problems.


Five years on, it is clear that while OpenFlow has a place as an enabler for some specific point-solutions, e.g. the Google Espresso MPLS-GRE tunnel gateway, the proposition of wide scale deployment of pure OpenFlow based production networks has few takers. The development of OpenFlow protocol has stalled, and there is no supplier of OpenFlow capable switches with capacity to match the current conventional technology leaders `legacy' MPLS based core switching systems.
Arguably, P4 has now taken the place of OpenFlow as the SDN research poster child or standard-bearer.

%: we look forward to the first academic paper combining P4 and SDX!

\medskip

Nonetheless, there are lessons to be learned from SDX, and SDX ideas \emph{have} contributed to real world IXP infrastructure.
The purpose here is not to critique SDX work \emph{per se}, except where the tension relates to Internet transit as much as to IXP.
An example of this is the requirement to react to Internet routing changes in a timely fashion: this has been a focus of SDX work, yet the solutions developed clearly are not even close to being adequate for the requirement: this might not be an issue if there were viable development strategies for scaling up.
A related problem is ensuring the systems that are built respect the protocol rules safeguarding Internet stability, and the equally important policies that safeguard Internet operators' commercial interests.
These are also common concerns in the field of BGP and transit, albeit with nuanced distinctions in regard to detail - yet the SDX BGP routing engines play fast and loose with both technical and commercial integrity.
With this degree of licence the route processing challenge is rendered significantly simpler, but nonetheless the described SDX prototypes are not adequate even in their own terms.

\medskip

%\textcolor{red}{DH: edited up to here now ...}

Part of the problem is the ambiguity in the SDX requirement: in truth, the Princeton SDX project appears to be aimed at producing a superset of a core peering router - supporting all of the external BGP routing and forwarding capabilities of a transit ISP, augmented with OpenFlow inspired `deep packet' processing, the while implementing constraint checking for authorisation and routing consistency over these augmented policies to provide a `multi-tenant' control interface.
In its first incarnation the chosen tools are single threaded Python language systems which implement neither real-time service interfaces nor a compliant BGP speaker, and the second implementation is hardly more sophisticated, based still on single threaded Python libraries that are not designed or optimised for soft real-time applications.


%\textcolor{red}{[DH: Can you check the para below and point out the `difference' ...]}
%\NH{I'm restating the cricisms of SDX work and asserting that my work avoids them.  Every item in the next senctnce is one of the distinctions.....}

There is an important difference between SDXes and this thesis. Although the thesis is focused on transit ISPs rather than IXP infrastructure, the challenges and solutions proposed in the thesis work are also applicable for SDX at IXPs - and \emph{this thesis} aims to meet the relevant scalability and performance goals, while maintaining routing integrity and stability, at the same time observing commercial policy considerations.

Most importantly, for this thesis, it should be, and is,  achieved without requiring modification or upgrades to existing systems.
Reinforcing the relevance criteria of the thesis, it is argued that in fact the many of the stated goals of SDX work are more effectively addressed by upgrading transit ISP systems rather than upgrading IXP systems.

%\footnote{\textcolor{red}{DH:This footnote needs to be revised and located in the body of the chapter.}
%\NH{Done, it is in the new section 3.4.?.?}
%}



% \NH{\textbf{Here is the argument for keeping routing policy out of the IXP.....}}

% An important premise of the thesis is that the principal obstacle to better Internet is neither more flexible or performant forwarding plane behavior, or more flexible or performant control plane behaviour, rather more flexible and performant policy, which can perfectly well be served in existing forwarding plane and control planes.  In the existing Internet architecture the nexus of policy implementation is reserved to the domain of transit ISPs.  SDX proposistions aim in part to shift some aspects of routing policy into IXP systems, without articulating an argument for that shift, or analysing the possibly negative consequqnces of doing so.

% Superficially there are some grounds for the proposition that some aspects of transit routing policy might migrate to IXP based systems, e.g. Route Servers, becuase, as IXPs facilitate an increase in the degree of direct connectivity between edge ASes, routing decisions that would otherwise have been located in a transit or multiple transit ASes are now removed to the domain of the edge AS peers.  The core question then is whether the locus of policy control formerly excesised principally by transit providers, should relocate into the IXP domain, or instead relocate into routing processes within the intereconnected edge networs themeslves.
% When expressed in these simple terms, the answer seems obvious: if the entire purpose of deploying edge network links at IXPs is to eliminate the costs and limitations of going via transit: then if the IXP is to present as a sustantive functional element between edge networks, mediated via BGP, then what is the IXP than simply another transit network operating under a false flag.

% But, in the original conception of an IXP architecture, the role of an IXP Route Server in that context, if engaged at all - which, for imporatant peer relationships, it would not be - is only to provide to corresponding peers the peer route unmodified, so that direct peers may apply their own policy to select or reject the direct route.  Only if the IXP has  independnet contetxual data which is not available to the corresponding peers is there a basis for changing or suppressing a route relayed between peers.  So whilst there may be some policy role for the IXP, it is at best trivial, and an attempt to augment the role in complex and novel ways is as likely to be disruptive as it is to be constructive.  Critically, the IXP as mediator for direct peer links cannot be a route selector between multiple potential alternatives.

% The point is that there  is a simple binary choice to be made when traffic shifts from transit to direct links, as to where the responsibility for sound routing policy is better located - either in the corresponding peers or in a third party IXP system.  But the corresponding edge peers must anyway configure their systems to accept or reject specific peers, so the most that can be expected from th eIXP is a simple static filter.  A counter argument might be that a small edge AS may lack the capability to properly manage their IXP peering, but it's not a particulalrly plausible argument.
% }}


%\textcolor{red}{DH: edited up to here now ...}

\subsection{SDX}\label{subsection-SDX}
The initial paper \cite{Gupta2014} in the SDX category takes a familiar tone of decrying the (allegedly unnecessary) complexity, inflexibility and inefficiency of today's Internet and Internet architecture, and then proposes a range of what are surely non-problems that it claims or implies urgently require solutions:


\emph{
The Internet's routing problems result from three characteristics of the Border Gateway Protocol (BGP), the Internet's interdomain routing protocol:
\begin{itemize}[noitemsep,nolistsep]
\item{Routing only on destination IP prefix. BGP selects and exports routes for destination prefixes. Networks cannot make more fine-grained decisions based on the type of application or the sender.}
\item{Influence only over direct neighbours. A network selects among BGP routes learned from its direct neighbours, and exports selected routes to these neighbours. Networks have little control over end-to-end paths.}
\item{Indirect expression of policy. Networks rely on indirect, obscure mechanisms (e.g., “local preference”, “AS Path Prepending”) to influence path selection. Networks cannot directly express preferred inbound and outbound paths.}
\end{itemize}
}

Earlier attempts to build just such a \emph{deterministic Internet}, using cell based technology under the banner of ATM, failed for multiple reasons, amongst which were that:
\begin{itemize}[noitemsep,nolistsep]
	\item{It did not scale.}
	\item{It was too expensive.}
	\item{There was no economic model for strictly allocating and accounting for resources that aligns with the Internet economic model.}
	\item{Cheaper solutions worked well enough, sometimes better.}
\end{itemize}

Any attempt to resurrect the idea of QoS enabled global data networks risks failing for the same reasons, and is surely a bigger project than SDX is conceived to be, yet this is surely the implication of this attack on BGP and conventional Internet routing architecture.

A more complete treatment of this theme, is in the later section
\ref{sec:The problem with explicit QoS}.



Moreover, given the relatively small role of the IXP in the overall Internet topology, it is hardly practical to reference these global considerations in the context of work within the IXP domain: if the Internet did not work the way it does, then most likely also the need for IXPs would be different or even non-existent.


The usecases the SDX publications address are not manifestly hard, open, problems, lacking solutions; neither do the proposed solutions require uniquely SDN specific capabilities in order to implement them.
The four applications are:

\begin{itemize}[noitemsep,nolistsep]
	\item{Application-specific peering}
	\item{Inbound traffic engineering}
	\item{Wide-area server load balancing}
	\item{Redirection through middleboxes.}
\end{itemize}

Taking these issues case by case:
\begin{itemize}[noitemsep,nolistsep]
	\item{\emph{Application-specific peering}
	            Specific use case highlighted: YouTube and Netflix.
	            The paper argues that `ISPs are increasingly interested in application-specific peering, where two neighbouring AS exchange traffic only for certain applications' No references for this assertion are given, however!  Perhaps because it is much easier to address this problem by treating all traffic to/from Netflix IP's as video?  Which is how it works, very well indeed, today!  The idea that introducing network flow classifiers (presumably peering deeply into encrypted https traffic!) rather than just treating all traffic to Netflix as Netflix traffic is just plain stupid!  Or, if it isn't it needs a really good explanation of why not.}
	\item{\emph{Inbound traffic engineering}
	            Well, yes - IP routing generally does work by destination based routing (although transit ISPs already break this generality internally by using MPLS).
	            But the external issue, which is really just a subset of the asymmetric path issue, is absolutely fundamental, not just to BGP, but to IP.
	            But it is an end-to-end problem, and if the structure of a useful solution could be agreed then we have technology (MPLS, SR) which could address the problem already.
	            But the implications for scaling, let alone the impact on the business model, are the big issues to solve, not the relatively simple question of how to build the dataplane domain at an IXP.}
	\item{\emph{Wide-area server load balancing}
	            First, this is largely a solved problem, and the solution is along the lines indicated, and do not require SDX.
	            And the specific criticisms of current solutions are certainly not correct today, whether they were in 2014 is also open to doubt (why would you care about a one-off  additional DNS lookup delay in the millisecond range when loading a piece of content which will play for an hour?)  And, why do you need to `rewrite the destination IP address to match the chosen hosting location based on any fields in the packet header' when you could just hand out the (implied) anycast address in the first place?}
	\item{\emph{Redirection through middleboxes}
	            Firstly,as the linked text suggests, this is primarily an enterprise requirement: secondly, to the extent that this is an ISP requirement, BGP-flowspec and MPLS tunnels perform exactly the function described, with no need for an SDN implementation (which, it would appear, would need to be in every border router in the network, not just at an `SDX' site.)}
\end{itemize}

%\textcolor{red}{DH: edited up to here now ...}

\subsubsection{Open questions on SDX solution architecture and requirements}
The proposal is that the SDX presents to every ISP as a `virtual' SDN switch, such that the actual implemented forwarding behaviour consists of the logical combination of the rule sets of each independent connected network.
However, in order to not allow conflicts or writing rules which affect other networks, the virtualised switch is presented as connected (meshed) with all other switches in the virtual switch cluster, and each ISP programs just its own switch.
This leaves the reader asking what the benefit of the scheme is over simply each one having its own physical switch (with the same programmability), physically meshed with all of the others - i.e. the status quo.
This is especially so when one considers that every ISP anyway has its own IXP site switch/router.
The fundamental open questions for SDX are:

\begin{itemize}[noitemsep,nolistsep]
	\item{What are the network level semantics which are provided which are not otherwise available?}
	\item{Which of these new semantics cannot be achieved by simple isolated SDN switches, interconnected by a high performance conventional switch?}
\end{itemize}

\subsubsection{SDX: Architectural challenges for routing level functions in an IXP}
A consistent theme in the treatment of SDX is the balance of functionality between the IXP `fabric' and the interconnected edge ASes.  In the early stages of IXP growth, the IXP proposition was rather simple: provide a low cost low function neutral meeting point and allow corresponding networks to mutually peer on a bilateral basis.  The extension to some degree of shared layer 2 network connectivity maintains the proposition of facilitating high density but purely bilateral interconnection.  Even the addition of Route Servers can be seen as simply a more scalable optimisation that preserves the underlying architecture of high density bilateral peering, rather than any more active or dynamic `transit like' role for an IXP infrastructure.
While it is certainly the case that IXP service offerings have broadened in the interval since the work reviewed here, there is little evidence in subsequent developments of the `intrusive' functionality on the scale or scope proposed in these papers.

In \cite{Richter2014} the  usage of `plain' Route Server capability is shown to be widespread in the ISP and IXP global community.  Later reports in 2022 \cite{Mazzola2022} and 2019 \cite{Madory2019} support the proposition that although not entirely transparent, IXP RouteServers continue to be used in rather conventional and simple roles, i.e. to the extent that they are more than simply route-relays; they provide general and specific filters, with specific filtering under direct control of the connected peers, facilitating only control over a too general distribution of routes, and general filters implementing `hygiene' level filtering, e.g. against bogons
\footnote{bogons are IP addresses which should never be routed, including but not limited to RFC1918 private address space - see \url{https://manrs.org/2021/01/routing-security-terms-bogons-vogons-and-martians/} for details}
and other clearly unwanted routes.

%\textcolor{red}{[DH: please explain] bogons}
%\NHx{done i hope...}


A general argument against anything more intrusive in the IXP BGP  routing domain is implicit in the cited work, but for the avoidance of doubt it is provided here.

%\textcolor{red}{DH: edited up to here now ...}

\paragraph{An argument for keeping routing policy out of the IXP}
\smallskip

%%% \textcolor{red}{[DH: I think you need to add a few sentences on what policy is, what is currently in place, and why you believe it's important for ``improving the Internet" ...]}
%%% \NH{ I need to check if i have not already written on this, e.g. in the BGP chapter.  But, it easier to write something short for now...:}
%%% \\
%%% \\
%%% \textcolor{red}{[DH: That looks OK.]}

\textit{ \textbf{Policy:} In BGP systems, `policy' means the discretionary intent which underlies specific routing control related configuration. By discretionary is meant, rules which are not mandated, but which are widely applied within an AS.  Policy implies generic directives, even if policy implementation requires specific configuration statements.   Some basic examples are the customer/peer/provider route preference and filter logic (described in the section x.x.x).   Policy in general is oriented with business or service integrity objectives.
\\
\\
This definition of policy directly supports the proposition that routing policy lies in the realm of the connected networks rather than the IXP fabric - since the business objectives of connected networks may not all be aligned of even compatible, and furthermore, connected networks may not wish to disclose their internal policy to external parties.  The final point is that unless ALL policy implementation is delegated to the IXP, the challenge of dividing responsibility for different aspects of policy between and external agent and internal systems is likely very hard, both to do, and to validate. }

A central argument of this thesis is that improving the Internet hinges less on enhancing forwarding or control plane flexibility and performance, and more on achieving flexible, performant \textit{policy}. Such policy improvements can be implemented using existing forwarding and control plane technologies. Currently, within the Internet's architecture, policy implementation primarily resides with transit ISPs. Proposals like SDX suggest shifting some routing policy functions to IXP systems, yet they often lack a clear justification for this move, or an analysis of potential negative consequences.

On the surface, migrating certain transit routing policy aspects to IXP-based systems, such as Route Servers, seems plausible. As IXPs increase direct connectivity between edge Autonomous Systems (ASes), routing decisions formerly made within one or more transit ASes naturally shift towards the peering edge ASes. The fundamental question becomes: should the policy control previously held mainly by transit providers move to the IXP infrastructure, or should it reside within the routing processes of the interconnected edge networks themselves?

Expressed simply, if the main goal of deploying edge network links at IXPs is to bypass the costs and limitations associated with transit providers, then empowering the IXP to act as a significant functional element between edge networks using BGP effectively turns the IXP into just another transit network operating under a misleading label. This undermines the original purpose of the IXP.

Furthermore, in the initial IXP concept, a Route Server's role—if engaged at all, which might not occur for important peer relationships—was merely to relay peer routes unmodified to corresponding peers. This allows direct peers to apply their \textit{own} policies for selecting or rejecting the direct routes. An IXP might only justify changing or suppressing a relayed route if it possesses independent contextual data unavailable to the peering networks. Consequently, while a minor policy role for the IXP might exist, it should remain trivial at best. Attempts to augment this role in complex and novel ways risk being more disruptive than constructive. Critically, an IXP acting as a mediator for direct peer links cannot serve as a route selector between multiple potential alternatives, because logically they should not exist\footnote{If two disparate peers at an IXP advertise the same direct route, then one of them must be `lying'. }.

Ultimately, when traffic shifts from transit to direct links, there is a straightforward choice regarding where the responsibility for sound routing policy is best located: either with the corresponding peers or within a third-party IXP system. Since the corresponding edge peers must configure their systems to accept or reject specific peers regardless, the maximum function realistically expected from the IXP is simple static filtering.

\textcolor{red}{[DH: And you need to add diagrams here and there to illustrate the role of, for example, IXPs.]}
\NHx{placeholder for diagram (B) }


\subsubsection{SDX: SDN Issues}
The common thread in this
%\textcolor{red}{[DH: chapter or thesis, not paper ...]}
%\NHx{resolved?}
chapter is to find a role for SDN enabled data planes in `real world' networks.
The problem with this proposition is that the additional operations which SDN uniquely enables are not obviously useful even for many general networking applications, but in particular have low relevance in core networks, where the numbers of individual network flows are immense, transient and very difficult to classify and correlate with specific policy objectives.
In consequence, three generic objections arise repeatedly to specific points in the paper:
\begin{itemize}[noitemsep,nolistsep]
	\item{The described function at a dataplane level does not require SDN features.}
	\item{The solution does use an SDN unique method, but other equally good solutions are available which do not require SDN.}
	\item{The problem described is not one which is applicable to core / Internet backbone networks.}
	\item{The problem described is not a dataplane issue at all.}
\end{itemize}
A more general objection or concern to the deployment of SDN based solutions is operational: traditional network technologies have well-developed and well understood techniques for management and troubleshooting, and SDN alternatives are unlikely to be deployed until they offer comparable levels of management capability.
In a clean-slate/end-to-end-SDN environment this operational challenge is already challenging -  but, in a heterogeneous end-to-end environment, where SDN must interoperate with classical networks, it is essential that SDN islands provide management and troubleshooting tools compatible with their adjacent classical peer networks.
An orthogonal issue is resilience: classical networks have good solutions for both device and network level resilience: distributed layer-2 and layer-3 path selection architectures do not rely on centrally calculated state specific explicit port selection and header modification rules: in contrast, SDN data-planes require very specific rule sets which typically require bulk replacement in order to respond to even minimal topology change.

An additional, recurring theme in the paper is that there are some incomplete proposals that have obvious issues: examples include the proposal for `application specific peering' : in \cite{Gupta2014} 
%\textcolor{red}{[DH: which paper?]}
%\NHx{}
it is suggested that
\emph{``An ISP could configure its edge routers to make different forwarding decisions for different application packet classifiers (to identify the relevant traffic) and policy-based routing (to direct that traffic over a special path)."}
\\but observes\\
\emph{``Still, such an approach forces the ISPs to incur additional routing and forwarding state, in proportion to the number of traffic classes, and configure these mechanisms correctly. SDX could instead install custom rules".}
\\But how is \emph{``SDX installing custom rules"} different to \emph{`configuring its edge routers to make different forwarding decisions for different application packet classifiers'}, other than (in the latter `conventional' case) the semantics of the configuration are clear, and the operational support processes well defined, whereas in the SDX case the encoding of VRF semantics requires custom user defined rules, written in a low level language with no mature development environment, and no operational support (OAM) available at the network application level.

%\textcolor{red}{[DH: edited up to here now]}

\subsubsection{SDX routing performance}
A particular constraint in the SDX system is on real time response to BGP updates:
\begin{itemize}[noitemsep,nolistsep]
	\item{The authors report that the central route processing system, with careful tuning, is capable of calculating required updates, after small BGP route changes, in ~100mS.}
	\item{The authors do not report the time taken to complete forwarding plane updates, nor whether such updates are non-disruptive for in-flight traffic.}
	\item{The authors do not report the latency performance for large scale BGP changes, e.g. peer up/down events.}
\end{itemize}
In contrast, conventional BGP speakers (and PIR), are at least 1,000 times faster to process equivalent routing inputs.

\subsubsection{SDX: Summary}
SDX proposes a clean-slate approach to BGP peering, with a focus on enhancing dataplane functionality while maintaining the existing AS-to-AS, end-to-end, (BGP) control-plane architecture.
Rather than ISPs peering directly via layer-2 fabrics, SDX presents as an intermediate transit network/border router itself: SDX offers ISPs mechanisms to define their peering policy and delegate the implementation to the SDX system, rather than within their existing border routers at the IXP.
The policies enabled have both dataplane and control plane semantics which largely mirror the existing configuration capabilities of proprietary core routers, enabling what would be called policy routing in conventional routing terminology.
SDX does not offer mechanisms to change or enhance the quality or method of routing decisions made by BGP network devices - rather it treats the issue of BGP routing policy as a problem in expressing and implementing deterministic/static rules where there is no ambiguity in any of knowledge of network state, business intent or expected or actual traffic loads, and no awareness of dynamics in either routing state or routing policy..

In summary, SDX offers three directions of change for IXPs:
\begin{itemize}[noitemsep,nolistsep]
	\item{centralisation/delegation of policy enforcement to an IXP hosted SDN system;}
	\item{re-deployment of traditional internal functions such as traffic engineering and scrubbing into the shared central IXP fabric;}
	\item{an SDN based re-implementation of a layer 3/4 aware dataplane;}
	\item{substitution of classical `CLI config' policy for a novel DSL (albeit not clearly more high level than existing configuration approaches;}
	\item{Non-real time latency for processing BGP updates.}
\end{itemize}
\subsection{iSDX}
Two further paper extend the iSDX project:

\smallskip

\begin{itemize}[noitemsep,nolistsep]
	\item \fullciteinfo{Antichi2017}
	\item \fullciteinfo{Bruyere2016}
\end{itemize}

\smallskip


In Gupta's original imagining of iSDX\cite{Gupta2016}, ( referenced already under the section SDX, since it is one of the original listed `Princeton Papers',)  the iSDX authors observe \emph{`Since we introduced SDX, many organisations and networks have built different versions of this concept. Yet, many of these deployments remain relatively small-scale or limited in scope because current switch hardware cannot support large forwarding tables, and because efficiently combining the policies of independently operated networks as routes and policies change presents a significant scaling challenge.'}


Even this statement overstates the degree of adoption in the references cited: none of them are SDXes, none of them are production networks, or claim to be, except for an application at TOUIX which is used to build an L2 fabric with ARP flood protection - which is not and does not claim to be, an SDX.



Continuing in \cite{Gupta2016}: 
\emph{``In this paper, we tackle these scalability challenges with the design and implementation of iSDX, an industrial-scale SDX that can support interconnection for the largest IXPs on the Internet today."} \\
The earlier works cited propose a single centralised controller, administering a single, centralised switch.
The new work articulates the, some might say, obvious limitations of this approach, and proposes a decentralised strategy - i.e., closer to how conventional IXPs work today\footnote{i.e. an IXP is built around a number of layer 2 switches, not just one....}.
In this `new' approach, traffic is `labelled' according to its fabric egress point - i.e. the clients have to `classify' (route) traffic before dispatching it to the fabric - the resolved layer two address is used as a lookup key for the fabric SDN override operations.


It is difficult to take any of this seriously - it is not clear at all what value or even what function is performed by the iSDX, above that of an L2 switch - except the ability to define, if required, forwarding rules which work above L3.
Quite how this can maintain any degree of integrity with respect to consistency of forwarding and control plane is unclear, or indeed why the respective IXP clients would not simply apply their own L4 ACL rules to the same effect.


This author is not alone in questioning the SDX proposition - in \cite{hermans2016}, the feasibility of converting AMS-IX to an SDX is rigorously debunked by  \citeauthor{hermans2016}, at AMS-IX.  However, they are rather reserved in their language - their cited objection to converting AMS-IX to an iSDX is the simple lack of scaling capacity - there were no OpenFlow capable switches with sufficiently large flow tables (the authors didn't consider it worth evaluating how quickly the existing 
 maximally sized tables could be re-written when needed...).  


But the primary existential issue is hinted at in \cite{hermans2016}rather than high lighted - in section 4.2 we hear:


\textit{`Converting AMS-IX to an iSDX might require a fundamental change in the operational model of the IXP and the way in which the platform is built. Furthermore, incorporating the concept of iSDX would mean that the AMS-IX has to start operating on higher network layers. \textbf{From a neutrality standpoint, it would be preferable if interdomain Traﬃc Engineering (TE) between participants remains transparent to the IXP.}'}


And,

\textit{`Deploying BGP FlowSpec over iSDX poses several signiﬁcant advantages for AMS-IX. Primarily, as the intelligence is moved to the customer edge, the IXP does not need to interfere with semantics of layer three and above. \textbf{This allows an IXP to remain in a neutral position.} Another advantage of FlowSpec is the ease of implementation, as BGP constructs are well known.'}

So, the IXP based authors suggest that iSDX is changing the operating principle of an IXP in ways that IXP operators perceive as contrary to the IXP philosophy.   It's a complementary perspective to the critique made here, that the IXP customers are unlikely to welcome this reorientation. 


Ironically, the subsequent Princeton SDX paper `Authorizing Network Control at Software Defined Internet Exchange Points' \cite{Gupta2016a} attempts to resolve the consistency issue by proposing a global overlay control system for all SDXes (but does not discuss how to resolve the problems that just one SDX can trigger).


A final criticism, if any is required, for the iSDX value proposition of L4 specific routing is that it breaks entirely IDR BGP philosophy and the `contractual assurances' implicit in advertising routes to peers; that is, when a route is advertised, there is a promise that all traffic matching that route (i.e. that prefix) will be forwarded over the path advertised by the prefix.   As soon as a network peer introduces the practice of diverting just some traffic, based on, for example, the layer 4 header of an IP packet, then there is no basis for trust in the routes advertised - because, if the route used is anything other than the route advertised then what route is it? How can routing loops be avoided?  How can connectivity issues be diagnosed?  And what path is reported by ping or traceroute?

While it is acceptable for a terminating AS to handle traffic internally as it chooses, the same can never be said for a transit AS.
So, for an IXP to silently and partially substitute BGP driven forwarding rules for some potentially catastrophic alternative, controlled by an opaque and novel SDN controller, is surely something that no serious network provider would or should contemplate.
\subsection{Umbrella}

Umbrella is described in a 2018 paper `Rethinking IXPs’ Architecture in the Age of SDN' \cite{Bruyere2018}
That paper reports work described in mode detail in Bruyere's 2016 Thesis\cite{Bruyere2016}, and some insights are derived from a reading of that thesis.

The motivation for Umbrella is a phenomenon described much earlier, in 2009, at AMS-IX, described at that time in a paper entitled `Effects of IPv4 and IPv6 address resolution on AMS-IX and the ARP Sponge'\cite{wessel2009}.

The AMS-IX problem was that excessive ARP traffic induced failures in BGP sessions of some IXP members colocated routers.  It appears that the pure software solution described as an `ARP sponge' effectively mitigated the issue at AMS-IX.  Presumably, upgraded routers and/or better configuration discipline has since resolved the issue as a general problem for IXPs, and indeed any other pure layer 2 networks, with the peculiarities of AMS-IX in 2009.

However, in \cite{Bruyere2018} it appears that around 2015 a much smaller IXP was still subject to similar issues.  Umbrella is the title of the solution, which involved deploying a layer of OpenFlow switches in front of every switch port in the IXP, thereby enabling ARP traffic to be managed in a novel way via an OpenFlow application based on Ryu.  The relevant outcomes of this work to the thesis are limited compared with other SDX work, since the actual issue and resulting SDN application is not directly related to IXP specific functionality, being rather just a simple fix for a problematic, generic, layer 2 scaling challenge.

Perhaps more interesting is what the paper has to say in passing about SDX and SDN in general:

\textit{`While IXPs are the ideal vehicle to extend the benefits promised by Software Defined Networking (SDN) to the interdomain level, reliability and scalability are essential aspects of an IXP that cannot be compromised by the introduction of SDN.
Consequently, \textbf{transforming IXPs from their legacy design into SDN-enabled fabrics is plagued with challenges}.
In particular, the impact of control channel disruptions or outages can cause severe disturbances, potentially affecting hundreds of networks and huge traffic volumes.
Moreover, control plane failures in large scale deployed SDN networks outweigh largely data or management ones combined together.'}


and later:


\textit{`We envision SDN-enabled IXPs that enhance the controller’s role as an intelligent supervisor, rather than \textbf{an active and dangerously critical decision element}.
Umbrella is the first step in this direction.'}

% \NHx{fixed hopefully}
% \textcolor{red}{[DH: OK]}

\subsection{Endeavour}
Endeavour \cite{Antichi2017} acknowledges and builds upon both iSDX and Umbrella \cite{Bruyere2018} \footnote{In fact, Umbrella and Endeavour related papers cross-reference each other.  But it seems that the implementation work under the Umbrella flag precedes the Endeavour work.  Given the strong implied criticism of SDX in the Umbrella paper, it's interesting to ask why the critical points made in \cite{Bruyere2018} are not in some way acknowledged in  \cite{Antichi2017}. }


%\textcolor{red}{[DH: Do we know already what this is?]}.


%\NHx{fixed hopefully by the references}


Unlike Umbrella, it follows iSDX in using BGP routing state as part of its forwarding paradigm.
However, it adopts the `Umbrella' architecture (a lead author is from the Umbrella group).
\\
As in iSDX, Endeavour aims to provide an augmented L3 fabric, in which the option is to redirect traffic, based on SDN policy, to any IXP member that advertises the destination address range.
The implicit assumption is that a member ISP may wish to override its own BGP based route selection outcome with static rules (defined by that same member) for some or all traffic to certain destinations.
It is not explained why this could not be better accomplished simply by configuring local BGP policy.
In iSDX much was made of the capability to use L4 header data in this policy: in this context L4 aware functionality is perceived to be a unique SDN capability - a serious misunderstanding: the uniqueness is rather the ability to control L4 policies remotely/centrally, at greater scale and more rapidly.
However, the examples given, in which policy is long term and not dynamic, are certainly possible without recourse to SDN/OpenFlow.
Endeavour de-emphasises arbitrary L4 policies in favour of more IXP fabric related features: viz. load balancing and rapid recovery, coupled with scalability advances over iSDX design.
The significance of this change of emphasis is significant: the original premise of SDX was that IXP members could benefit from customised user-specific L4 aware functionality which was not enabled in their own infrastructure, or which more effectively applies in the IXP infrastructure rather than internal.
Endeavour has moved on (or given up on) this premise: the SDX proposition now is `fix the ARP problem, then enhance the IXP fabric further in its existing functional role'.
However, while the scope has changed, the solution design is still aimed at providing SDN/OpenFlow override to traffic forwarding, at the granularity of destination addresses rather than just IXP egress ports.
It is worth examining the Endeavour use-cases to see if this Internet-route-table scale control is required for the job at hand.
The example applications given for Endeavour are: 1) IXP Internal Load Balancing, and 2) IXP Fast Failover Recovery: neither of these requires visibility of the BGP derived route table, and neither requires layer-4 aware processing.  It is notable, however, that in their Evaluation, the authors make reference to another feature - blackholing.
But while blackholing does operate at the granularity of at least the destination IP address (and probably more, though the paper does not say what their specific capability is), it does not require access to BGP or to a route table.
It is also arguably of little application to most direct peering relationships.

%%% \textcolor{red}{[DH: At this point, I need to suggest that the detail in this chapter feels a little excessive -- and I'm wondering how it might be reduced without too much work. For now, let's leave it as it is ...]}

%%% \NH{ACK, for me issues with the existing related work is an important theme.  Some related work i see as aligned, the giants shoulders.  But a lot is more `how not to do it'.}

%%% \textcolor{red}{[DH: We need to discuss in due course.]}

\subsubsection{Endeavour Use-cases}
Having shown that Endeavour does not appear to require the L3/L4/BGP aware capability which underpins the complexity of the design, it is worth examining the use-cases described, to see if the claims for an SDN based benefit are substantiated.
It is worth quoting in full the paragraph describing the problems with \emph{“today's Load Balancing Mechanisms”}, and the benefits accruing from the \emph{“Simpler SDN-Based Load-Balancing”} that Endeavour promises.
%(Warning: you may need to support your chin whilst reading this!)


%\textcolor{red}{[DH: edited up to here now]}


%%% \textcolor{red}{[DH: Do you really need the use cases that follow??}

%%% \NH{I think that I am following in the footsteps of John Day here a little...., but hopefully with more substance.

%%% Perhaps Luther would be a better analogy.

%%% The SDX authors are prominent, to put it mildly.  I'm calling them out by methodically demolishing the basis of the SDX cathedral.  I'm saying that that the SDX bandwagon was not just a bit overdone or misconceived, but actually an abomination from the beginning, and the authors ought to have known better.  By wasting resources on the wrong topics they devalue the whole community.

%%% This coffin needs a lot of nails, to be sure the thing inside cannot escape.

%%% (these use cases are a few more nails)

%%% }


%%% \textcolor{red}{[DH: Again, we should discuss.]}

\textbf{Main use-case \#1: Simpler SDN-Based Load-Balancing}


\emph{“Today's Load Balancing Mechanisms Are Hash-Based.
	\\
	Even though a portion of the overall traffic might remain local at a certain edge switch, a large fraction of the overall traffic needs to traverse the IXP fabric. This large quantity forces network operators to carefully configure their internal routing paths in order to optimise the load per link within the IXP network.
	To this end, large IXPs deploy highly symmetrical topologies and use ECMP Routing to equally spread the load among their internal links. In hash-based ECMP, the hash of the flow identity (i.e., IP addresses and transport port numbers) is used to deterministically select the outgoing port. Thus, ECMP guarantees that each packet of the same flow is forwarded along the same path.”}

    
\smallskip

Nothing to disagree about here except the curious statement, \emph{“This large quantity forces network operators to carefully configure their internal routing paths in order to optimise the load per link within the IXP network.”}
Quite why internal routing needs to be carefully configured is not clear:  assuming that an ISP does have two physical ports at an IXP, they are almost certainly equivalent from a traffic and routing perspective: and so a generic ECMP internal design is likely to be optimal in terms of spreading traffic over the two egress ports.
And if they are not equivalent, then almost certainly the peering associations of the IXP ports will be different too, in which case ECMP is not applicable at all.

\smallskip


The main problems are in the next paragraph:
\textit{Simpler SDN-Based Load-Balancing: We rely on a simpler, yet effective, mechanism for load balancing traffic across the IXP fabric. Instead of employing the “black-box” optional capabilities of commercial legacy switches, such as hash-based forwarding, we capitalise on the features available in any OF-enabled switch. In particular, we compute the outgoing port according to the least significant bits in the IP source and destination addresses, as also proposed in \ldots. This mechanism provides a main advantage: while a black-box solution cannot be easily upgraded if not suitable any more, this simple load balancing technique can be adapted on-demand.
\\
Our evaluation demonstrates that this approach attains a load balancing performance comparable to hash-based approaches in multi-hop topologies. This is a crucial gain in the IXP context, where replacement costs are high.}

    
\bigskip

Contrary to the implication above, commercial network equipment typically offers a choice of ECMP hash algorithm: for example, both Cisco and Juniper have a remarkably wide range of default hash algorithms, including a simple L2 source+destination method.
They also both offer a mitigation strategy for the well known problem of multiple hashes in sequence failing after the first hash, something for which the Endeavour strategy has no obvious solution, and the ability to customise the precise algorithm required.
See e.g. Juniper documentation \footnote{\url{https://www.juniper.net/documentation/en\_US/junos/topics/topic-map/switches-interface-aggregated.html-id-configuring-the-fields-in-the-algorithm-used-to-hash-lag-bundle-and-ecmp-traffic-cli-procedure}}.

\smallskip

So, the Endeavour ECMP hash is without question the poorer solution.
Moreover, the paper fails to articulate or reference any problem impact arising from existing `legacy' systems ECMP hash algorithms which would motivate this work.
On the other hand, quite how well Endeavour will cope with more than two ECMP paths, or the rapid response needed as ECMP paths are added or removed from the link set we cannot know from the paper: but one can be reasonably sure that the answer is `probably not as well as the legacy vendors equipment'.
\\
Note: the paper referred to as [24] describes a complex, load sensitive, data-centre specific optimisation, in contrast to this relatively simple IXP requirement.
The cited paper requires real-time traffic metrics to achieve small improvements in fairness of load distribution over large numbers of servers.
Furthermore, given that an IXP fabric is an entirely shared infrastructure, and so excessive physical link load is as likely to be external as local, there is no basis for thinking that the approach described in [24] ('Niagara') would be beneficial in the IXP context.


\smallskip

\emph{Simpler SDN-Based Load-Balancing: Summary}
The implied problem does not exist; in fact legacy equipment has a superset of the Endeavour features; and the hinted at possibility of further enhancing ECMP to a dynamic hash is neither required nor applicable in the IXP shared virtual link context.

\smallskip

%%% \textcolor{red}{[DH: Hmm, again for discussion ...]}

%%% \NHx{for clarity, I justify the statement directly in the preceding text, I am not sure if that answers your reservation?}

\textbf{Main use-case \#2: IXP Fast Failover Recovery}

\textit{Legacy IXPs Have Limited Fast Reroute Capabilities: To attain the highest reliability within the IXP fabric, IXPs currently leverage the fast re-routing capabilities of the legacy routing protocols (e.g., OSPF, MPLS).
\smallskip
Upon any internal link failure, such mechanisms quickly reroute packets towards their designated egress ports along a pre-computed alternate path. The extent to which these approaches improve network robustness is, however, inherently limited by the lack of information about alternative IXP egress ports through which traffic can be rerouted. As a result, whenever a link connecting an IXP egress switch to a member's BGP router fails, all packets forwarded through that port are dropped, a highly undesirable behaviour from an operational perspective. For example, any member with two ports connected to the IXP fabric might desire to receive traffic through any of these two ports whenever a port is down or the sending member may want to reroute its traffic towards a different member in case of failure.}


\medskip

Firstly, it is correct that there are known specific weaknesses in IXP architecture when a Route Server is deployed.
However, this paper does not describe the specific problem at all - \emph{(Which is that use of a RouteServer can mask data-plane failures because the BGP session would normally follow the same path as the user traffic, so in combination with BFD, rapid failure detection and re-routing is simple.)}

\medskip

Secondly, it is incorrect to say that \emph{“IXPs ... leverage the fast re-routing capabilities of ... OSPF,  MPLS”.}


They do not, as they are L2 networks.


In L2 networks, such as IXPs, link failures are fixed up for aggregated/redundant links transparently even to L2, and for non-redundant links by a spanning tree algorithm, however IXP members with multiple physical ports will in any case operate their own failure recovery procedures, and will have diversely routed links as far as possible within the IXP fabric, to cater for just such failures.

But the essential, wrong-headed, premise here is that fast-reroute effectiveness is constrained by the lack of information about eligible alternative paths at L3, not L2.
In other words the solution to an L2 failure which cannot rapidly self-heal is to reroute at L3.
And of course this is true - and is exactly what the IXP member networks do when an L2 failure at an IXP or anywhere else is detected.
But they neither need, nor expect, nor can manage an L2 network which quietly performs topology reconfiguration based on L3 insights.

\subsubsection{Endeavour: Summary}
Endeavour is in some ways the most flawed part of the SDX work: it aspires to be a prototype for real-world deployment, whilst it combines and rejigs the complex OpenFlow architectures of iSDX and Umbrella, retaining a direct live-feed from a BGP Route Server.
\\
It implements a proprietary source routing scheme, which depends on synchronising the content of distributed OpenFlow tables and an ARP Proxy, and changes in either BGP or local topology require updates to these tables.
\\
Whilst a claim for fast-reroute is made, it is not evaluated how this performs, nor what is the impact on other unaffected traffic whilst tables are rebuilt.
\\
It is clear from the discussion on various optimisation strategies that there are constraints on the scale of the system due especially to the limited size of OpenFlow tables, but what those limits are or the implications for future growth are not mentioned.
\\
A further caveat: there is no mention of IPv6 functions, and IPv6 support in OpenFlow is known to be very variable and incomplete, depending on equipment vendors.
In consequence, Endeavour appears unlikely to provide equivalent functionality for IPv6 applications as IPv4, and hence is rendered unattractive for a majority of operational service providers.
\\
Possibly the most troubling is the consistent implication that the default usage of the IXP corresponds to a simple transit network, in which there is a common set of routes to which all members subscribe, and that this represents the bulk of the usage of the IXP; and worse, that IXP members would be happy to have traffic routed outside their control simply in response to IXP topology failures.
This is in contrast to the widely held understanding that the primary usage of IXPs is for direct links between content providers and access providers; that the role of Route Servers is to simplify the control plane tasks, each IXP member having a simple limited `view' consisting of those peers routes which have been explicitly subscribed.
In this perspective there is not one or more common `full route tables', accessed via the Route Server, from which an IXP member is likely to have multiple eligible routes.
This is not to say that transit servers are not present at IXPs, or even that in some cases a transit server may not advertise full route tables via an RS.
But it does suggest that in terms of actual traffic exchanged , and priorities for protecting and optimising  that traffic, default transit is not an important element.
IXP members contract with specific chosen transit providers, and carefully manage their routing to those providers - not usually through an IXP RS.
Having explained why the full-route-table / BGP focus of Endeavour is misplaced in terms of IXP usage, we now mention the problem with the Endeavour use-cases, which in any case no longer justify the complexities of supporting full-route-tables in OpenFlow: the two main Endeavour applications are a novel OpenFlow based link load balance scheme, for SDX internal links only: which unfortunately is a small and defective subset of the standard ECMP hash algorithms widely available in legacy vendor equipment; and the `fast-reroute' scheme (whose actual speed is not measured), but which works by rewiring L2 topology to entirely different destination ports, based on inferred knowledge from L3 route tables.

\subsection{SDXes: Timeline, Summary and Conclusions}

\subsubsection{SDX Timeline}
The term SDX originated
%%% \textcolor{red}{[DH: Should you have introduced this earlier ..?]}
in presentations in 2013 by Nick Feamster, at ONS~\cite{feamster2013}, and Arpit Gupta (NANOG 59, 2013), and the subsequent paper `SDX: A Software Defined Internet Exchange' \cite{Gupta2014}.
In Gupta2014 four use cases are examined:
\begin{myitemize}
    \item Application-specific peering
    \item Inbound traffic engineering
    \item Wide-area server load balancing
    \item Redirection through middleboxes
\end{myitemize}

and an architecture is presented which centralises policy for all members of an IXP, enabling an outsourced fine-grained traffic control mechanism within the IXP switch fabric.
It is not clearly motivated why the functions described need be done external to the individual ISP network, and there is no claim that benefits to existing IXP functionality can be realised.
The design solution combines exaBGP and Pyretic, and requires offline table builds to respond to network topology change.
\\
iSDX \cite{Gupta2016} refreshes SDX with a new, more decentralised architecture, whilst implicitly maintaining the same use cases/motivations of Gupta2014.
A side paper by the same authors, \textit{Authorizing network control at software defined internet exchange points} \cite{Gupta2016a}, uses iSDX to implement a third party controlled filtering scheme to mitigate DDoS attacks by writing flow rules within the iSDX fabric.
Endeavour \cite{Antichi2017} describes and addresses a perceived shortcoming in iSDX, which is that iSDX cannot scale above a `single box' solution, whilst real world IXPs typically have tiered switch architectures, with aggregation and core switches.
Endeavour implements a source routed solution using overloading of L2 header fields and an OpenFlow enabled switch architecture.

Endeavour builds on the `Umbrella' scheme developed by M. Bruyere in \cite{Bruyere2016} in \textit{An Outright Open Source Approach for Simple and Pragmatic Internet Exchange} and deployed at a small IXP (TOUIX).
Umbrella is an SDN L2 switch designed to address a very specific issue - ARP broadcast overload.
Otherwise, Endeavour tackles similar use cases to ISDX.

\textit{Rethinking IXPs' Architecture in the Age of SDN} (Bruyere2018) complements the earlier SDX work with a less ambitious but more realistic agenda, which is a refreshed articulation of `Umbrella' (Bruyere2016).
Bruyere2018 deftly articulates the difficulty of integrating BGP control plane operations with IXP L2 infrastructure, and instead proposes an architecture which retains conventional BGP architecture and focuses on the challenges of scaling and hardening IXP L2 infrastructure within the scope of existing IXP service portfolios.

\subsubsection{Paths Not Taken - SDX, The 2013 perspective}

An early reference to SDX is a presentation given at the Open Networking Summit (ONS) in 2013, which is listed first on Princeton University's SDX publication summary web page. This ONS presentation shares an identical title, `SDX: a software defined internet exchange', with an ACM SIGCOMM paper presented the following year, leading to potential confusion.
\footnote{
As of 2025, no online copy of the 2013 ONS presentation can be found.
However, a presentation with the same title, attributed contributors, and presenter (as listed on the Princeton University publication list) given the previous month at IETF86 is still accessible on the IETF website. The following analysis assumes that the content of these two presentations was substantially similar.
The IETF document is available at \url{https://www.ietf.org/proceedings/86/slides/slides-86-sdnrg-6.pdf}.
}
\footnote{Beyond differences in content, there are also discrepancies in authorship: the lead author of the ACM paper was not a contributor to the 2013 proposal, and a Google contributor to the original presentation was no longer listed in the SIGCOMM paper.}

The 2013 ONS presentation posited that since Software-Defined Networking (SDN) had already been successfully applied to domains like data centres, campuses, and enterprises, it might also be applicable to the broader Internet.

The presentation listed a range of hypothetical use cases and also catalogued limitations and issues associated with the Border Gateway Protocol (BGP).

\bigskip

%\textcolor{red}{[DH: edited up to here now]}

A preliminary design, titled `A Preliminary SDX', was outlined in the presentation to address two specific use cases: dynamic route selection driven by a price-based auction, and route selection mediated by a `reputation' system to mitigate prefix hijacking.

Alternative designs to the `one controller' concept embodied in `A Preliminary SDX' were also mentioned. Several shortcomings of the `one controller' design were enumerated, which could impact even the described applications. For instance, the Forwarding Information Base (FIB) might become too large, and issues of trust and reliability could arise if IXP customer policies were delegated to the IXP infrastructure. The final slide of the presentation called for further research, primarily to identify concrete use cases and subsequently to develop architectures tailored to those use cases.

This presentation is best understood as a stimulus for discussion rather than a definitive blueprint for immediate implementation. Notably, it highlights a perceived flaw in BGP: the potential for BGP to advertise a route that differs from the one actually implemented in the data plane. This is precisely one of the criticisms that applies to the subsequent SIGCOMM SDX design, where this discrepancy is not merely a potential issue but an inevitable one.

Nowhere in the presentation is OpenFlow mentioned, nor is there any stated requirement for OpenFlow-specific capabilities. The described controller-based system features a `FIB', not flow tables, and operates with routes, not flows.

It seems clear that the authors did not have a fixed stance on whether SDN-based solutions for inter-domain routing (IDR) `issues' should be situated within IXP infrastructure or within existing Autonomous System (AS) frameworks. There is minimal explicit connection between `SDX' and `IXP': the term `IXP' does not appear anywhere in the presentation, and the term `exchange' appears only once, in the context of the outline design for the auction-based routing use case.
\bigskip

In conclusion, an alternative evolutionary path for SDX could have been pursued. This path might have involved: interviewing potential users and building architectures to match use cases proposed by this target audience; incorporating the warnings about scalability and control issues into the design of experiments to validate SDX; considering the suggested advantages of SDN controllers and switches managed by network peers rather than centrally; and taking seriously the dangers of advertising routes that do not correspond to the forwarding plane.
The presentation does not assert that SDN can resolve all, or even any, of the IDR issues it describes. Instead, it poses the question of whether, and how, SDN can contribute to addressing them.
%%% \NH{To Be Continued} \textcolor{red}{[DH: OK]}

\subsubsection{Summary}
Generally, there is an apparent conflict in the core of the SDX proposition - and few if any of the use cases described for SDX exclusively demand an SDX to accomplish them, neither are some of them clearly IXP specific, or even IDR relevant, problems; in many cases they appear better accomplished within an ISP network than outside it.

A traditional IXP is a purely L2 functional system providing virtual point-to-point connectivity: a complex mesh of simple direct links.
The operational semantics of a mesh of point-to-point L2 links is simple: packet fate is predetermined on entry. However, any SDN action destroys the integrity of this mesh: packets may be dropped, modified or redirected in transit - the complete opposite of the simple concept of traffic following paths managed at layer 2, or even at layer 3. The resulting hybrid system becomes very difficult to manage and troubleshoot.

It is also hard to understand why any three or more parties\footnote{`three or more' because the layer 4 specific rules would distribute traffic which is logically between just two parties, based on layer 3 semantics, over more than just one 'layer 3' destination path.} that desire to distribute traffic according to complex rules amongst themselves would rather not do so using traffic management capability within their own domains, based on simpler external L2 connections.

A good example of just such a practice is the SDN edge systems deployed by Google and Facebook, which accomplish exactly the stated objectives for SDX.
To formulate a compelling use case for SDX, it is necessary to explain why a function is better accomplished in the SDX than in the IXP client networks.
One `obvious' use case for SDX is to automate the operation of the IXP function as it exists already: an obvious `problem' in current IXP infrastructure is that it is open to traffic on every path between every port, while the only legitimate traffic is that between peers who have agreed to exchange traffic.\footnote{The Google supported `Cardigan' project\cite{Stringer2014} does address this issue to some regard, albeit whilst introducing other capabilities.  The Cardigan paper is a good example of work which transparently acknowledges the limitations of a technology or architecture: in the Cardigan case, SDN and OpenFlow.  One cannot read \cite{Stringer2014} and be left understanding that it represents any more than, as the authors describe it, `a poster-child for the concept of hybrid SDN-IP networks'.  In particular, it should be noted that Cardigan is not, and does not claim to be, an architecture for an IXP, or SDX.  As the authors describe it: `Cardigan, a SDN-based distributed router'.  It is not clear what if any features are enabled in Cardigan that would not be feasible or practical using existing proprietary routers.  And, no such claim is made for Cardigan.}
The only operational SDX system described in the literature is just such a system, with the unambitious but useful objective of mitigating the impact of unwanted ARP traffic arriving from peers that would not be permitted if the `obvious' strict rules were applied.
\subsubsection{Conclusions}
Early versions of SDX envisioned close integration with BGP routing, which would represent a close alignment with the programmable transit routing proposed in this thesis. However, careful analysis supported by subsequent work under the SDX banner shows that the likely practical contribution of an SDX approach is quite far removed from end-to-end routing issues.
(This is perhaps not surprising, since the classical raison d'être of IXPs is not to provide transit service.)
\\
\\
In contrast to SDX, the applicability of this work to IXP operations is rather in the implications for scaling IXP Route Servers rather than enhancing the IXP forwarding plane.
But there is a contradictory position too: even though an IXP is certainly not a transit AS, the parallels between the two are close, especially when the Route Server administered domain is the focus.
In a modern transit network the internal packet transport is L3-agnostic - MPLS, or in the future SR; the same is true in principle of the IXP fabric, and the most valuable contribution of SDX is in assisting the transition to a cleaner fabric, comparable to the modern transit core.
The L3 transit core leads to a system in which internal  BR-to-BR path selection is managed as a fabric of (L2) point-to-point paths agnostic of external L3 routing semantics, whilst external route selection is delegated to individual BRs acting autonomously, and in which intermediate routing plane systems (RRs) are used to aggregate offered routes and mitigate scale issues arising from the large numbers of BRs. Analogously, the model IXP implements a virtual L2 point-to-point fabric, and an RS for exactly the same reason as the transit RR.
In both cases RR or RS has a responsibility for selecting `best' routes, in the simple default case a single global selection, while optimisations are addressed by RR/RS presenting BRs/peers with customised route views.
SDX represents an attempt to optimise the IXP architecture by merging the management of L3 and L2 IXP operations; this specific strategy founders on two points - the first being that there is no clear optimisation gain which requires a simultaneous L2/L3 view. This is in contrast to transit where L2 considerations have a direct impact on performance and resource utilisation, which then feeds into selection preferences at L3 - the transit issue arises from the geographically distributed nature of transit networks.
The second difficulty encountered by SDX designs is the one of routing scale and performance when attempting to make the IXP fabric an `augmented' L3 routing fabric - modern border routers with optimised pipelines, distributed architectures and relatively simple L3-only forwarding semantics struggle to meet the performance demands of core Internet applications - so it is hardly surprising that novel prototypes are challenged in this dimension - and that the response is to move away from centralised configurable fabrics to edge centred designs.
\\
\\
% \textcolor{red}{[DH: Again, I see the need for suitable illustrations of the ideas being discussed -- some simple Figures if possible ...]}
% \NHx{placeholder for diagram (A) }
\NH{placeholder for diagram (A) }

\section{SDN Edge}

The two papers in the category of \textit{SDN Edge} are more recent publication (2017) than other work reviewed so far, and postdate the initial literature survey for this thesis. They are:

\begin{itemize}[noitemsep,nolistsep]
	\item{Google Espresso \cite{Yap2017}}
	\item{Facebook Edge Fabric\cite{Schlinker2017}}
\end{itemize}
These papers and the work they describe are very different from other related work, in that they describe concrete operational systems with many of the same characteristics as Transit ISPs, e.g. scale traffic volume, performance and availability requirements.
We can be sure that lessons taken from this work could be applied to IDR, to the extent that they address common issues.
Where this work diverges from this thesis is in the specifics of the problem - optimising traffic distribution for performance and efficiency - and, in this context, a single large stub Autonomous System.

\subsection{Challenges}
Both papers, and the projects they describe, are very similar: similar problems solved in similar fashion.
Google and Facebook deliver Terabits of traffic to 100s of millions of users via thousands of diverse network paths.
Even if the internal resources are not oversubscribed there can be problems of capacity in delivering to users, impacting service quality, if only default routing strategies are used.
And, if better routing can be achieved then internal resources can be used with higher efficiency too, leading to cost savings.

\subsection{Solutions}
The common objective in Google Espresso and Facebook Edge Fabric is to improve on default routing strategies in ways that are capacity and traffic aware.
This requires intensive traffic measurement and analysis and fine-grained routing control to apply the outcomes of the analysis.
The intended outcome is to dynamically and incrementally shift egress traffic flows to alternate paths, away from those which standard BGP routing would otherwise direct.

\cite{Yap2017} and \cite{Schlinker2017} differ in specifics: Espresso pushes full Internet forwarding tables (FIBs) to every content host, and while EdgeFabric used this strategy in earlier incarnations, the current reported version moves granular routing responsibility onto a separate hardware entity.
However, the design intent is identical, which is to dynamically route internal traffic at the globally visible prefix level, with distinct routing across the estate
Both solutions employ conventional IP tunnel techniques such as GRE and MPLS
EdgeFabric relies completely on standard routing techniques, employing an active BGP speaking `route-injector' to configure override routes directly onto internal routers on; Espresso similarly uses conventional BGP for the global routing control channel, but rather than controlling routers directly Espresso incorporates an OpenFlow controlled switch element to configure classical IP tunnel encapsulation and forwarding functions.
\subsection{What do the papers report?}
The papers describe the problem space, the engineering solution, and motivations for the design, complemented by traffic measurement and analysis that demonstrate the effectiveness of the solution.

\subsection{Risk, and the Big Red Button}
Rather than avoid disruptive change entirely, Google and Facebook take a different approach, which is to accept and manage risk. Arguably this is easier for them as a single organisation than for a federated system such as the global Internet - while Google and Facebook radically change internal systems, the visible external behaviour remains consistent.
Moreover, Google and Facebook can migrate their entire internal `customer base' to completely new interfaces and architectures, with no need to retain legacy; and, their internal customers are remarkably homogeneous compared to the global Internet. Finally, when change is enacted, Google and Facebook can detect failures or even minor performance impacts, in real time, with a possibility to unwind breaking changes if needed.
Nonetheless, Google and Facebook deploy cautiously, with design strategies such as the `Big Red Button' (Google \cite{Yap2017})   - control levers that enable selective disablement of advanced features.
Another aspect of their philosophy is the reliance on existing protocols and building blocks wherever possible.

\subsection{Summary}
Facebook and Google have designed and deployed entirely new architectures to address their own very specific requirements.
Both Google and Facebook have similar requirements, and their solutions are also similar - although they both describe their approach as `SDN' based, only the Google solution uses OpenFlow, and that is used to drive a single solution element to perform externally `non-SDN' functions, i.e.
define mappings between MPLS encapsulation and GRE tunnels, functions that routers with static configuration can equally perform (specifically, the dataplane capability is not something that only OpenFlow can provide, but the control-plane semantics do not map to any current routing protocol).
It is appealing to consider that the `white box' open architectures in these designs could be smoothly and profitably migrated into a transit ISP environment
However, the lesson from both Google and Facebook is that the conventional solutions of BGP are close to optimal, and the complexity of the radical approach adopted yields only incremental benefits, and only because of the intensive traffic monitoring capability and the fact that for these edge systems the content and thus the traffic source is under the same control as the peering optimisation infrastructure.
\\
To translate this directly into a transit network would require a degree of data sharing and trust that is simply not available even between directly peered transit and content or access ISPs, yet for most transit traffic even this level of proximity does not exist - and for transit network operators even the commercial objectives are not sufficiently aligned with the customer networks to make such a degree of coordination practical.

\subsection{What are the lessons for Transit ISPs?}
%\textcolor{red}{[DH: You need to make this into a set of bullet points, I suggest.]}
%\NHx{done}

The following observations may be made:
\begin{itemize}
    \item Real-time detailed traffic measurement is essential for dynamic routing.
    \item The benefits are incremental (in percentages less than 100, not in multiples).
    \item The technical (QoE) benefits may come at a real economic cost - traffic spilled from peering onto transit costs money.
    \item The required system complexity is much greater than the equivalent classical IP routed architecture, even though the underlying system, though large, is highly homogeneous.\footnote{an outline of the remarkable level of complexity is given in the later paper from Google authors \cite{Krentsel2024} - one dimension of complexity is the more than 2 million lines of new code.  This paper suggests that although `successful' is some sense, the complexity and fragility of a centralised controller based system is ultimately unsustainable, even for Google.  This later paper charts Google's roadmap to decommissioning the project described in this section. }
    \item The SDN approach is possible without SDN style dataplane extensions.
    \item Although `flow'-based, flows are managed at the level of routing prefixes, not individual sessions / host addresses / application / port numbers.
\end{itemize}


It is germane to ask: could transit ISPs benefit from this approach?  Plausible answers to that question are as follows:

\begin{itemize}
    \item Equipment costs: probably not - both solutions retain conventional Border Routers.
    \item Bandwidth costs: probably not - ISPs already strictly avoid routing traffic unprofitably - having the capability to reroute traffic to less profitable / more costly peers is not a revenue generator.
    \item Operating costs: probably not - the solutions require more complex systems, overlaid on a conventional routing architecture.
    \item Google and Facebook have very capable fault and performance management systems that mitigate some of the complexity - which is an additional cost.
    \item The cost of building and running such a system would be beyond any but the very largest ISPs' budget or skill sets.
\end{itemize}

%\textcolor{red}{[DH: edited up to here now]}

\section{Artemis and Argus}
\subsection{Artemis}
Published in 2018, Artemis \cite{Sermpezis2018} presents a detailed practical approach to detecting malicious BGP routing traffic in real-time.  The focus of the paper is on analysis of the attacks, the available real-time data sources which allow the attacks to be observed, and the required analytical approach to accurately identify attacks with sufficient precision and confidence to enable an effective mitigation.  The Artemis paper describes both substantial simulation and a prototype implementation.  The implicit target user for Artemis is the local ISP providing connectivity to Internet application services (end users, in network terms).  However, the applicability is broader, i.e. transit network operators remote from hijack victims might also usefully deploy Artemis, if they also have a mitigation mechanism.
\\
\smallskip
\\
Artemis complements this thesis: it carries a small section on mitigation, which is interesting in itself - from it the limited scope for mitigation in current Internet environment is clear.  Two mitigation strategies are offered:

\begin{itemize}
    \item \emph{`Self-operated mitigation with prefix de-aggregation'}
\end{itemize}
and

\begin{itemize}
    \item \emph{`Outsourcing mitigation with MOAS announcements'}.
\end{itemize}

The Artemis paper acknowledges that the first mitigation has limited efficacy - in fact for many vulnerable services it is likely that this strategy is already in use - so that any attack detected by Artemis is already strong enough to overcome it.  And the second strategy amounts to surrender - the term \emph{Outsourcing mitigation with MOAS announcements} does not do justice to the implications of the method - which essentially amounts to switching from standard Internet connectivity to a parallel proprietary network which has ubiquitous direct connectivity to every significant access network of interest.  While this approach may work for sophisticated organisations with deep pockets, such as banks or other commercial concerns, it is of little help for smaller organisations.\footnote{Incidentally, this balkanisation of the Internet is a good example of trends highlight and deprecated in the papers cited and reviewed later: `Can We Save The Public Internet?' \cite{blumenthal2024} and `Revitalizing the public internet by making it extensible' \cite{Balakrishnan2021}}
\\
The intersection between Artemis and this thesis is clear: if transit ISPs closer to the source of BGP attacks were able to detect problems using Artemis, how would they implement mitigation?  The answer is simple: PIR.  Artemis is a perfect example of an external routing analysis component that to be effective should be integrated with the BGP route selection process, but may not be able to react in the timescales which BGP routing decisions demand.  PIR allows just such an asynchronous call-out to Artemis-like services.
\subsection{Argus}
Argus is similar, presented in an older paper than Artemis\cite{argus1}\cite{argus2}
% \textcolor{red}{[DH: reference needed here]}
% \NHx{done}
- with a wider scope in terms of the attacks it can identify, and uses some different techniques to validate possible attacks and remove false positives.  An Argus-inspired system takes longer to react to attacks and provides a different class of detection.  The Argus paper provides less insight into its implementation details, and says even less on the subject of mitigation approaches - in fact, nothing at all.
\subsection{Conclusions from Artemis and Argus}
The state of the art in BGP attack \textit{detection} is much more researched and capable than for BGP attack \textit{mitigation}.  However, the decomposition of the problem into detection and mitigation is clearly useful - perhaps the next step would be to formalise the requirements for a common interface between such systems, one which also allows for the aggregation of inputs from multiple detection systems.
\\
A direction for further work is to ask if either of these approaches lends itself to detection of unintentional BGP routing failures, for which PIR is equally applicable as a mitigation technique.

\section{Fibbing and Swift Reroute}
\subsection{Fibbing}
Published in 2015, `Fibbing' (Central Control Over Distributed Routing) \cite{Vissicchio2015c},
and the related implementation report `Sweet little lies: Fake topologies for flexible routing'  \cite{Vissicchio2014}, describe an experiment with OSPF,
in which a software controller speaking OSPF is introduced into a network.
By generating additional fake node and link announcements, the controller is able to influence traffic flows.
Cited use cases for Fibbing include:
\begin{itemize}[noitemsep,nolistsep]
	\item{traffic redirection / scrubbing for DoS mitigation;}
	\item{balance load over multiple paths;}
	\item{provision backup paths.}
\end{itemize}


\textbf{Relevance}  Fibbing targets carrier network's internal traffic management, rather than external routing policy.
However, the approach of working with existing protocols without modification,
control exerted through a software controller operating on a peer level with legacy routers,
and the non-disruptive fail-safe strategies is closely aligned with this thesis.


There is much to agree with in this work; for instance, the authors comment on the challenges of a full SDN approach to add value to existing networks:
\\
\\
\emph{``Software Defined Networking (SDN) could easily solve the problem, as it enables centralised and direct control of the forwarding behaviour.
However, moving away from distributed routing protocols comes at a cost.
Indeed, IGPs like OSPF and IS-IS are scalable (support networks with hundreds of nodes), robust, and quickly react to failures.
Building a SDN controller with comparable scalability and reliability is challenging.
It must compute and install forwarding rules for all the switches, and respond quickly to topology changes.
Even the simple task of updating the switch rule tables can then become a major bottleneck for a central controller managing hundreds of thousands of rules in hundreds of switches.
In contrast, distributed routing protocols naturally parallelise this work.
For reliability and scalability, a SDN controller should also be replicated and geographically distributed, leading to additional challenges in managing controller state.
Finally, the deployment of SDN as a whole is a major hurdle as many networks have a huge installed base of devices, management tools, and human operators that are not familiar with the technology.
As a result, existing SDN deployments are limited in scope, e.g., new deployments of private backbones and software deployments at the network edge."}

\smallskip

This observation closely mirrors the perspective on SDN offered in this thesis. However, whether `Fibbing' is itself quite up to those same challenges is not so clear.
%but comes from the pen of such respected workers as Stefano Vissicchio, Olivier Tilmans, Laurent Vanbever and Jennifer Rexford!

\smallskip

The authors go on to say:


\emph{``Fibbing differs from previous approaches that rely on routing protocols to program routers.
Prior approaches like the Routing Control Platform rely on BGP as a “poor man’s” SDN protocol to install a forwarding rule for each destination prefix on each router.
In contrast, Fibbing leverages the routing protocol implementation on the routers.
In doing so, Fibbing can adapt the forwarding behaviour of many routers at once, while allowing them to compute forwarding table entries and converge on their own
That is, while the controller computes the routing input centrally, the routing output is still computed in a distributed fashion."}

\smallskip

Again, these arguments are compelling, and this thesis makes a similar claim for its approach in the external routing domain: the existing network is trusted to operate under its default logic,
with an additional light touch external control agent, which exerts just as little direction as is needed to achieve the desired optimal result, which is rarely very far removed from the default outcome.
In the event of problems, failures or any concerns at all, the external override can simply be removed - partially or entirely.


The `gap analysis' for this work raises concerns mostly about the practical applicability of the work:
e.g. are the use-cases valid in current networks; are there other solutions to the same problems - and do the criticisms in the paper of some of these approaches stand up to examination;
what level of operational confidence can be associated with an intrusive design strategy like Fibbing - how would it cope under high stress? - is the gain worth the risk?
And, the paper makes no mention of hierarchical OSPF - would it work as well in that case? (Hierarchical OSPF is needed and used in the relatively small number of transit ISPs that use OSPF rather than IS-IS, and, Fibbing does not work at all in IS-IS, according to the paper.)


There are also some specific technical concerns over Fibbing's scalability and responses to failures, in spite of very specific text in the paper on the subject: a conventional OSPF network is rapidly self-healing under almost any circumstances - link failures are rapidly propagated by the nodes which remain connected - no special logic is required to protect against invalidated LSA database entries causing mis-routing, because if their originating nodes are partitioned then no path can be chosen which uses them.


The same statement is not true for Fibbing - `lies' may remain in the LSA databases of a partitioned network after the originator (the Fibbing controller) has been disconnected.
Clearly, the Fibbing authors were aware of this - their design response is indirectly exposed here: (page 12 of `Sweet little lies' \cite{Vissicchio2014}: \emph{``After about 1s, the injected lies disappear, because they are not refreshed anymore by any controller."}  In other words, Fibbing is deliberately limiting the lifetime of announced LSAs from the usual 30 minutes to just 1 second (the smallest possible value).  The paper does not discuss this further and in an earlier section reports a very small impact on router CPU utilisation even in the case of 100,000 fake LSAs - clearly in this case the announcements are not being refreshed at 1 second intervals.


\emph{(The extended version of the report goes into a little more detail - it says: ``we can set a low validity time of the injected lies, making them rapidly expire if not refreshed. This then comes at the cost of additional control-plane overhead." - i.e. you can have scalability, or rapid recovery, but not both.)}


Incidentally, BGP contrasts strongly with OSPF in this regard, and thereby avoids any such problem: a router connected with any other BGP speaker, including a specialised controller, will automatically drop any routes it received when the BGP control session to the controller is lost, and forward any necessary update routes, including withdrawals, to restore network state to the default status quo.


\textbf{Use case validity}
It is not clear which use case is the `killer app' for Fibbing - find none of them seem compelling, and for each of them there are available operational alternative solutions, most commonly based on MPLS-TE approaches or similar - and the evaluation examples are unconvincing - for example, the load-balance case describes a trivial 4 node topology in which an optimal outcome for a specific (trivial) load profile can be forced using Fibbing, by diverting one of two file transfers to use a 3-hop path rather than the IGP default 1-hop path. This example has so little relevance to carrier networks that it would be unfair to list all of the objections: the topic of dynamically optimising flows in carrier networks is complex, but this contribution is not helpful.


\textbf{Traffic scrubbing} In the example of `traffic scrubbing' however, the detail implementation is not described: though it is implied that it would amount to an insertion of external routes into the IGP - a practice which is highly dubious - but also the traffic scrubbing case seems not to allow for specific diversion based on e.g. source address or L4 headers.  It seems that the Fibbing approach is only partially effective, or would also require other configuration to effect.  Meanwhile, this is a problem which for many ISPs is already solved, and for which protocols like BGP-flowspec were very specifically designed to address.


\subsubsection{Summary: Fibbing}
In summary, the Fibbing project can be seen to fall between two stools - as an interesting exercise in how far OSPF can be moulded to accommodate routing policy it has interest,
but if it is to be considered as a serious alternative to more conventional approaches to the same problem then it needs to have a lot more work to address technical concerns and show its unique capabilities over other solutions.  Another particular concern is that the authors state that Fibbing has limitations - but we are not shown what they are.  Finally, network operators are traditionally very nervous about changes to their IGPs - Fibbing would face a very high cultural barrier to adoption, even in the minority of carriers that use it.


The appeal and relevance for me is the alignment of approaches, and the well articulated criticism of the validity of highly disruptive programs that target existing large scale service provider networks.

\subsection{Swift Reroute}
Published in 2017, Swift Reroute \cite{Holterbach2017}, Swift addresses the problem of slow recovery after remote network outages affecting large Internet service provider networks.
Swift mirrors PIR in deploying external analytical systems to improve on default routing policy outcomes of legacy routers, and take appropriate counter-measures in exceptional circumstances, if required.
While there are also many differences between PIR and Swift, it is possible that PIR could provide an alternative mitigation solution to the one adopted in Swift.  The novel contributions in Swift, over the general one of enabling programmable control to respond to exceptional network conditions, are:
\begin{itemize}[noitemsep,nolistsep]
	\item{a real-time inference engine for analysing BGP streams and deducing root causes of disruption finding as optimal mitigation;}
	\item {a strategy for maintaining service during route churn following upstream failures;}
	\item {a practical implementation of the mitigation strategy.}
\end{itemize}
\smallskip
\subsubsection{Background - Path Hunting}
The specific problem that Swift addresses is this: when a currently preferred BGP route fails, there may be an extended period of time before an alternative stable, viable, route is selected.
There can be various reasons for this, but one of them is that our network may already have apparently viable alternative routes, which are actually subject to the same failure cause as the first route, or may subsequently receive similarly unviable routes from the peer which had preferred route before the failure.
BGP itself has no mechanism for signalling the root cause of failures: worse still from an analytical perspective is that failures may not be evident at all: the source of the preferred route is as likely to simply replace it as withdraw it, but with a replacement which is itself already unviable.
This occurs because the upstream network is itself performing the same attempted recovery based on stale routes as our network.
\\\textbf{MRAI} There is another factor that exacerbates matters still further, which is `MRAI' (Minimum Route Advertisement Interval).  BGP implementations of MRAI (many, if not most - in some cases it can be disabled, but not in all, and a few BGP speakers do not implement it - however, it is required by the base RFC (RFC4271)).



MRAI slows the rate of Update transmission - a BGP speaker should wait for the specified MRAI interval (typically 30 seconds), before sending another update for the same destination.
Were it not for MRAI then the problem described earlier would likely rectify itself rather quickly, although there could be quite a large volume of Updates before it did so.
But MRAI slows everything down, and it may take multiple of the MRAI interval before a viable new route for a destination becomes available.
\subsubsection{Swift Mitigation Strategy}
Swift works by first identifying the start of a period of routing instability, and then chooses what is hoped is a safe, stable alternative route to use for the duration of the route churn.
Swift is only a passive player at the routing level - a `Swifted' router or network is unchanged from the perspective of end-to-end BGP convergence.
The Swift strategy is to temporarily disconnect the forwarding plane from the BGP routing state, but not notify external peers that it has done so.
The premise is that until the route has converged it is likely that the apparent `best' route as local BGP policy would decide is actually not best at all, in fact it is likely just another version of the failed route which has yet to be withdrawn or replaced.

\subsubsection{Swift Mitigation Implementation}
The high level description of the implementation is that Swift changes the forwarding path for affected prefixes to the egress port corresponding to the selected alternate `safe' route.
The essential aspect is that swift makes no changes in any routing protocol state (RIB), just in the forwarding state (FIB).
The paper states:
\emph{``SWIFT is easy to deploy.
	Only a software update is required to deploy SWIFT, since recent router platforms readily support a two-stage forwarding table.
	In §7 we show that SWIFT can also be deployed on any existing router by interposing a SWIFT controller and an SDN switch between the SWIFTed router and its peers.
	The two-stage forwarding table in that case spans two devices, similarly to an SDX platform [30, 31]."} 
    %(The references [3] and [31] are to the SDX and iSDX papers reviewed above).


\smallskip


When the authors state  \emph{``SWIFT is easy to deploy. Only a software update is required ..."} we should be cautious in our optimism - the implementation evaluated is a pure SDN/OpenFlow solution, which requires all user traffic transiting the AS to pass though an SDN switch which is directly in the datapath for all traffic to other internal peers (and it is not clear how SWIFT would work for traffic in which the preferred alternate route was via another peer on the same Border Router).  The sense in which the deployment on existing hardware is easy is the sense that such hardware is capable \emph{at the hardware level} of implementing the SWIFT datapath function.  There is no hint of the protocol solution that would be required to enable a SWIFT controller to instruct such a legacy router to follow the SWIFT mitigation directive.


\subsubsection{Swift: Analysis and Conclusions}
%\emph{It was the best of times, it was the worst of times}



There is a lot to like about the SWIFT proposition. For example, the inference engine and high level mitigation strategy are both credible and fully compatible, and even complementary to PIR:
where SWIFT is less strong is in its implementation approach.
Forcing traffic to take another path could be done in a few different ways; however, the approach chosen seems unsuited for a production network,
and the assertion that current routers could easily be modified to achieve the same result appears questionable, and should at least be justified.
Furthermore, the specific approach taken is motivated by an analysis of modern router forwarding plane performance, which is invalid: the examined system is not representative of the hardware used for Border Routers.
And, the issue of performance of forwarding plane updates is a legitimate but separate one topic to the core of the SWIFT work, which is about better response to large scale route failures.
It is possible to take the view that had PIR been available, the SWIFT team might have adopted it rather than follow the OpenFlow path.
\\
\textbf{The alternative PIR approach}   PIR issues override routes that take preference over the routes exchanged directly in the IBGP mesh.  To support SWIFT, all that PIR need do is advertise the \emph{old} route with the same path attributes but a different external next-hop.

\subsection{Conclusions from Fibbing and Swift Reroute}
Swift and Fibbing represent current thinking in Internet/SDN challenges.
They both take a more evolutionary direction than earlier work that involves disruptive and irreversible change across the whole network estate.
Only the minimum change to effect a better outcome is proposed.
The criticisms raised (or gaps perceived) are similar, but form a subset of those made in response to earlier work: the authors of both papers envisage a future in which legacy network hardware continues to operate with existing routing and management approaches, albeit supplemented by software driven controllers, with access to external state and able to make smarter routing decisions.
The difficult question, which they and this thesis both address, is how to achieve this goal in a gradual, evolutionary, way.

%\textcolor{red}{[DH: edited up to here now]}

\section{Bongo}
Published in 2016, Bongo \cite{Benton2016} is an implementation of a BGP speaker that is intended to integrate previously developed malicious route detection frameworks with an existing operational BGP network.


\smallskip
Superficially, BONGO and PIR represent two projects with almost exactly the same objective, which is to use fully programmable route analysis software to drive enhanced route selection procedures, and thereby prevent bad routes from being accepted and disseminated.
However, there are many differences between the two approaches: the bulk of the BONGO report describes previous work on the impact and tactics of abusing BGP routing, and methods for detection of bad routes.
The brief implementation section describes a high level architecture: BONGO is built on the exaBGP framework - BONGO receives routes and for those identified as suspicious takes one of three actions: drops the route; forwards the route modified by prepending the AS-path to make the route less likely to be chosen, or calls an external program which raises an external alert and delays propagation, propagating the route eventually if no response to the alert is received.


\subsection{Integration}

The integration of BONGO with a BGP network is described thus:


\emph{``The simple case is integrating with a normal BGP-speaking router.
	To enable this, the router can be configured as a standard BGP peer to Bongo like the upstream routers.
	In this case, Bongo will just be acting as route reflector but with defensive capabilities."}


%In response, one might say \textbf{the devil is in the detail!}
%%% \textcolor{red}{[DH: You need to add a sentence outlining the question that will then be taken up in the next paragraph (``this question; ...")]}

Much of the substance of \emph{this} thesis is concerned with this question; in contrast, BONGO seemingly does not acknowledge that there is an issue at all.
It is rather difficult to make a full comparison between BONGO and PIR because there is very little detail of the proposed deployment architecture.
Should BONGO be connected to external peers or internal peers, or both?
How should internal peers be configured with respect to BONGO?
It is stated that
\emph{``... Bongo will just be acting as route reflector …"}, if BONGO would connect to just internal peers.
\\ We are not told explicitly what BGP role BONGO plays: however, exaBGP itself is not a full BGP speaker, and it does not support a RIB, with all of the associated semantics.  This presents potential problems for BONGO.
\\ For example: if BONGO receives a route it rejects, previously having disseminated a route to the same destination, does it generate a withdrawal message?
\\ If BONGO receives a withdrawal for a route it previously disseminated, does it disseminate the withdrawal, too?
\\ If BONGO is receiving routes from two or more peers, does BONGO run a route selection / tie-break process?
\\ We note that  exaBGP does none of these things - it is not a RIB equipped BGP speaker.
Yet these are essential functions for a Route Reflector (RR) as well as implementation of the RR BGP extensions.
If BONGO is to perform a RR role, it must start with a fully functioning RR implementation.
And if BONGO is a full RR, then the performance figures given in the next section will make it a very difficult proposition to motivate.

There is another problem with BONGO too, one which the authors of RCP, IRSCP and others understood, which is: how can BONGO learn about all of the external routes available?
If BONGO rejects one route, but another route from the same BR was good, how can that alternate route be included in the route selection process?
And, if BONGO rejects a route, and somehow that rejection results in the route being replaced in the IBGP mesh, what then is to prevent the route being re-advertised, or enable a replacement route to be advertised?
\subsection{Performance}
The authors state:
\\
\emph{``The performance of Bongo is bound by two factors: the performance of the underlying exaBGP framework and the types of filters in the route acceptance engine.
\\
The underlying exaBGP framework is performant enough to operate at Internet exchange points, where it can process the global Internet IPv4 and IPv6 routing table from 6 different peers in just over 3 minutes.
\\
In local testing, the performance degrades significantly if the filters we have defined in the route acceptance engine have to do many database lookups.
\\
In one case, it took 5 hours to process approximately 3 million updates (full routing table * 6 peers).
\\
While this performance is poor during the initial peering phase, it’s still fast enough to handle the updates during normal BGP topology changes).
\\
In order to improve the performance, we are working on adding an asynchronous filtering mode where we allow exaBGP to participate at its full speed and then examine the forwarding information base it generates with the Bongo route acceptance engine in a separate task.
\\
Then, whenever it identifies a bad route, Bongo informs exaBGP to withdraw or modify the route.
\\
Adding the asynchronous model will give us a trade-off between full performance with small windows where bad routes may be accepted versus slower performance where every route is examined as it arrives."}
    
exaBGP is known not to be fast enough to function as an RR, which is confirmed by this section.  And that is when exaBGP is simply ingesting routes, not calling out to external programs.  At its best, exaBGP requires a Linux process schedule for every received Update.
BONGO, however, reports a specific 5-hour performance example, 5,000 times slower than native exaBGP.
\subsection{Conclusion}
The BONGO deployment model is not explained in detail. However, extrapolation from its brief description given suggests that it is one of the centralised IRSCP/Morpheus style designs.
Unfortunately, BONGO is not based on a complete RIB based BGP speaker - therefore it cannot function correctly in this way.  There is no obvious, simple way to rectify this.
\\
Just as BONGO has problems with functional completeness, it has severe problems with performance.
The suggest direction for further work is to move to an offline / asynchronous integration.
This is an interesting approach, and one proposed also in PIR.  However, there is no description of how this would work, and similar but more complex and novel issues arise for an asynchronous `RR' as arise in the more well understood case of an online / real-time intelligent RR.
\\
In conclusion, the BONGO concept is a simple one, and the challenges it exposes in delivering a functional solution serve as a good introduction and motivation for the PIR architecture described in the remainder of this thesis.

%\textcolor{red}{[DH: edited up to here now]}

\section{ravel and bolero}

\begin{itemize}

	\item {\textbf{ravel} (\textit{2016}):~A database-defined network
	      \cite{Wang2016}}

	\item {\textbf{bolero} (\textit{2019}): Enabling Policy Innovation in Interdomain Routing: A Software-Defined Approach \cite{Wang2019}}

\end{itemize}

\subsection{Background}\label{subsection-Bolero}

The later paper `Enabling Policy Innovation in Interdomain Routing: A
Software-Defined Approach' posits a perspective of the challenges in IDR which
is strikingly different to that presented in this thesis: it is particularly
noteworthy because of the relative currency (2019), and relative authority\footnote{One of the authors has co-authored at least 11 papers with Jennifer Rexford}
\footnote{NB: in the earlier critical review of the SDX work \ref{sec:The problem with explicit QoS}
%%% \NH{need reference?}
%%% \textcolor{red}{[DH: Yes ...]}
some of the concepts here have already been addressed, in terms of the limitations of scope for QoS services in the Internet.  The review here addresses somewhat distinct perceived misconceptions in the meaning of policy in the context of IDR and BGP networks in general.}.

To quote the abstract in full:

\emph{``BGP is known to restrict policy expressiveness and induce uncontrolled
	policy interactions that are hard to understand, reuse, and evolve.
	We argue that the use of a path vector system as the carrier of
	interdomain policies is the root cause of these limitations.
	To this end, we propose an alternative policy scheme built in a
	software-defined controller to decouple policymaking from the path vector system.
	Rather than treating policies as hardwired attributes of a route, that are
	configured and consumed as the route goes through the path vector decision
	process, we let policies flow, interact, and combine to influence end to end routes.
	This new software defined scheme creates new space for policy language, route
	decision, and conflict resolution design, towards more flexible policies,
	cleaner policy enforcement, and controlled policy interaction.
	As a realisation of our vision, we present an implementation that uses
	data integrity constraints for representing and reasoning about routing policies,
	addressing unique challenges in the decentralised interdomain environment."}

The first observation is that this abstract, and the full paper, seemingly embody fundamental misconceptions about the purpose and motivation of BGP based IDR networks; and articulating these misconceptions is more than a simply an
exercise in one-upmanship - it contributes towards defining the real challenges and constraints in the domain.

Let us unpick this issue a little:

\textbf{\textit{`BGP is known to restrict policy expressiveness'}} - this
statement is neither referenced nor explained,
but it is manifestly incorrect in its most obvious, concrete, sense: for
any transit AS, the scope of its `policy' is limited not by BGP as a protocol,
nor by BGP as an architecture, but only by the constrained modes of expression
of policy available - that is to say, a transit AS's freedom of action is
restricted to just two dimensions:

\begin{enumerate}
	\item independently, for every prefix ('route'), to choose which, if any, of upstream offers to propagate;
	\item when propagating a route, to choose whether, and how, the
	      community attributes received with the route, are modified and
	      re-transmitted downstream.
\end{enumerate}

But, since an AS has total freedom to select routes and mutate associated
community attributes, based on any combination of
(static) external factors (configuration) and community attributes received,
the scope for expressing, (and implementing) policy is hardly restricted at
all.
In practice, transit AS's make only very limited use of their freedom of
action, for example, transit ASes rarely if ever support arbitrary distribution
of disparate routes to disparate downstream \emph{transit} neighbours, either
singly or in a manner which would allow the downstream to select a preferred
route from an offered range.

However, the BGP \textit{protocol} does permit precisely that additional flexibility, using BGP ADDPATH, and the reason that it is not deployed, and neither is the alternative of delegating to the upstream a
non-default route selection, is for practical reasons: ~in the case of ADDPATH
with EBGP one reason is the combinatorial explosion of routes re-advertised which would arise, another
is that there is no widely applicable motivation for a downstream network wishing to
override the default route redistribution policy of its upstream neighbour. (If it were so important,
then the downstream ISP, or its demanding customer, would most likely provision a more
direct connection, possibly via an IXP.)
Even more significant, however, is that in a conventional transit network it is not even possible to enable diverse forwarding plane behaviour which would be required in order that control-plane advertised diverse routes were actually actioned in the forwarding plane of the transit network.
In the separate case of access providers, or transit ISP acting in the role of access provider, there is often
implemented some higher degree of `policy', in terms of very specific
prescriptions of which `customer' routes to advertise to which other peers.
\medskip

We move on to the following statement:

\textbf{\textit{`... induce uncontrolled policy interactions that are hard to understand, reuse, and evolve.'}}

This statement is, again, not referenced,
although, given that there is only one instance available for study, the
meaning of the expression may be that the \textit{authors} find policy
interactions \textit{in current Internet} hard to understand, reuse, and
evolve. To which a sceptic might suggest that an approach which broadens the
reach, content and semantics of routing interactions might be even more likely
to suffer from \textit{uncontrolled policy interactions} than the existing
system, which is tightly constrained, exhaustively studied and analysed, and
has the benefit of decades of experience in managing stability.

\medskip
And, next:

\textbf{\textit{`Rather than treating policies as hardwired attributes of a route, that are configured and consumed as the route goes through the path vector decision process, we let policies flow, interact, and combine to influence end to end routes.'}}

This, too, is rather difficult to understand - because, in today's Internet, \textit{policies} are
not exchanged between ISPs at all. This entire foregoing text and commentary
illustrates a common problem in this  domain, which is the precise use of
language. For example, \textit{BGP} is used to mean a very wide range of
things, from, at the narrowest, the wire protocol defined in RFC4271, through
implied semantics of RFC4271, and the wider range of IETF defined BGP protocol
extensions, up to the entire Internet system, including the organisational,
economic, political and social agents, and constraints, which make up the
Internet. Examining the precise use of the word BGP in this sentence:
\textit{BGP is known to restrict policy expressiveness}, it appears that the
intended meaning is specifically technical, and making the statement that there
are semantics that would be \textit{useful} to communicate between ISPs but
\textit{cannot} be expressed in BGP, and that part of the problem is that
BGP cannot express the semantics because it is limited to messages which are
associated with `path vectors'.

On deeper examination, another, even more
slippery word emerges frequently in this text: \textit{policy}. In fact, in
just 162 words, the word `policy' or `policies' is used 12 times. Two usages
stand out: \textit{`the use of a path vector system as the \textbf{carrier} of
	interdomain policies is the root cause of these limitations'} - and -
\textit{`let policies flow, interact, and combine to influence end to end
	routes'}.
It seems that here the meaning of policy is quite ambiguous: the authors seem
to believe that \textit{`policies'} are exchanged between ISPs.
Re-examining the initial first few words:
\textit{`BGP is known to restrict policy expressiveness'}
supports this interpretation: but, it is surely no surprise, that BGP
\textit{as a protocol} \textit\textbf{restricts policy expressiveness} - in
fact it does not simply restrict it, it does not allow it.

But the same expression can also be interpreted quite differently: for example,
to most network operators the meaning of the sentence
\textit{`BGP is known to restrict policy expressiveness'}
would be very different to the previous sense, and quite clear, even if they
might disagree with it: they would likely interpret it thus:
\textit{`\textbf{my} BGP routers do not allow \textbf{me} to configure routing
	policy as flexibly as I would like'} - but this is \textit{not} a
statement
about BGP as a protocol, or even a statement about the architecture, which
surely and inevitably leads, if not to BGP, then to something else very
similar; it is a statement about the software limitations of their existing
routers, and the consequent difficulty of implementing within their own network
anything more flexible.
Returning to the topic of the paper reviewed here, and its abstract, it seems clear that
there is fundamental divergence of usage over the words \textit{policy}, and
even \textit{BGP}.
\\
%\textcolor{red}{[DH: edited up to here now]}
But it also appears that there is more than just a difference of usage
involved: this paper also exhibits a lack of clarity about motivation and
goals: it is uncontroversial to state that ISPs are at times
collaborative/cooperative/transparent and at times
competitive/combative/opaque, allowing at least some possibility of enhanced
cooperation in the area of `policy'.
But beyond that abstract proposition the paper provided no clear suggestion
what kinds of collaborative working, not as yet adopted, might be of potential
value, and even less clear what cases might exist that could benefit from an
automated process based on dynamic policy exchanges.
Note: the point is not that there is no scope for evolution in this domain,
just that the motivation must surely be articulated before making a critical
analysis of the existing state of affairs.
The foregoing comments address issues relating to the application of policy
exchange between ISPs, which is the clear implication of the introductory text.
However, there is a complementary subject that the paper later undertakes,
which is the possibility of applying a software driven approach at an AS
internal level.

This aspect is strongly reinforced in the implementation side of the paper,
which describes a practical implementation of a routing policy system -
`bolero' - loosely based on `ravel', a previously published work by some of the
same authors: - `ravel' is an SQL based implementation of an SDN controller for
OpenFlow.
\\
%%% \textcolor{red}{[DH: edited up to here now]}

\subsection{`ravel' and `bolero'}

The first thing to observe is that \textit{ravel} is not \textit{bolero} -
in fact, based on the published papers,
the few points in common are authorship, and the fact that they both utilise a
database/language, Postgres as their implementation tool.
Like \textit{bolero},	\textit{ravel} also has its own idiosyncrasies -
principally that it is not
clear how SQL really contributes to the SDN controller design debate beyond
the	exposure of the fact that minimal SDN controllers are largely just
persistence engines which track previously installed network state,
where the actual required state is defined by higher level \textit{SDN applications}.

\textit{ravel} allows a network of OpenFlow devices to be managed: the target
application is not clearly expressed, but appears to be a multi-tenant DC/VPN
type application.
Ravel does not interact with any routing protocols.
In contrast, bolero is a pure SQL application which interacts with BGP route data
streams and stored BGP policy rules.
When neighbour peer originated routes are inserted/removed/updated via SQL requests,
bolero applies its SQL language
encoded policy rules to generate updated RIB output tables.
The paper shows implementations of two previous BGP policy proposals,
\textit{miro}\cite{miro} and \textit{Wiser}\cite{Mahajan2007},
and demonstrates that bolero can implement either or a combination of the two,
with a mechanism for resolving conflicts between the policy output, when they differ.
The reported performance of the system is around 2mS per route update,
i.e. processing a single full route table would take around 30 minutes.
~The implementation does not distribute the generated routes to the AS network infrastructure,
nor does it have an implementation to receive them.
~The practical contribution of the paper is an implementation of router BGP policy in an SQL form.

\textbf{What is the relevance of this paper to PIR?}
- PIR provides a model for integrating systems like bolero into existing networks.
The case the paper makes for such capability is strengthened by the
premise that a mechanism exists for implementing programmable routing in the
context of current production networks.

\section{Stabilizing Route Selection in BGP }

This 2015 paper \cite{Godfrey2015a} written by distinguished authors including Matthew Caesar and Scott Shenker and Ion Stoica
represents a powerful endorsement of the value of PIR and provides a concrete justification for deploying PIR based systems.
The paper quantifies the benefit of deploying
specific classes of programmable policy agents in IDR - its conclusions are
that doing so can improve resilience to service disruption induced by network
outages, to a very high degree when widely deployed, and deliver significant
benefits even in case of limited deployment in larger, Tier-1, transit networks.
The paper is complementary to PIR in that it offers an assessment of
the practical benefit for current Internet of deploying a programmable system,
and leaves as open questions the mechanism for implementation in production
networks, a gap which PIR is well positioned to fill.

% \section{xBGP: making BGP truly extensible}
%  % \NH{ *** DRAFT / VERY NEW MATERIAL (BUT IMPORTANT) ***}

% This work reported in this paper \cite{Wirtgen2020} is more or less contemporaneous with the work documented in this thesis.

% PIR (Programmable Internet Routing) was presented in 2019 at IETF106 \cite{hart2019},
% to an audience including at least one of the authors (Randy Bush), who made some interesting comments at the time, perhaps influenced by the then already in progress work with xBGP.
% The ACM paper \textit{The Case for Pluginized Routing Protocols\cite{Wirtgen2020} xBGP: making BGP truly extensible} was presented at IETF109\cite{ietf109xbgb}, exactly one year later, by Olivier Bonaventure.

% More material including slides\cite{Wirtgen2019}, video material, github links, are accesible at the xBGP site https://pluginized-protocols.org/xbgp/

% \NH{the following needs depersonalising...}
% On first reading, the  motivation and strategy behaind xBGP are so close to PIR that it seems almost too unlikely for mere coincidence, and would make me rather glad that I have the 2019 IETF presentation on record to show that PIR is not a derivative work.  However, the paper references my earlier publication in any case.

% My overall response to this conjunction of ideas is very positive - it can be seen as an endorsement of the analysis and applicability of this thesis.

% On examining the differences between the approaches: three distinctions
% immediately emerge:

% \begin{enumerate}
% 	\item at an architectural level, xBGP presumes that a sufficiently powerful
% 	      range of new capabilities can be achieved simply by an `eBPF' like
% 	      programming metaphor, to make the investment worthwhile.

% 	\item the xBGP agenda is to call for production grade BGP implementations
% 	      to make a one off extension to enable xBGP
% 	      - the proposition is that useful new capabilities can (and should?) be
% 	      implemented directly on active border routers which host the network forwarding plane.
          
% 	\item at implementation level, the xBGP approach is to modify production grade routers, FRR and
% 	      BIRD being examples, in contrast to PIR's build-from-scratch strategy.

% \end{enumerate}

% \subsection{Critique}

% \textbf{On the first point, concerning architectural aspects}
% xBGP works by inserting user written software directly into the BGP contrl-palne execution path of a BGP router.
% So, xBGPs scope of influence seems broad enough: it can exert \textit{influence} at all of the critical decision points of a canonical BGP agent.

% But, details are crucial -

% \begin{itemize}
%     \item Can an xBGP plugin both work with the outcome of the default algorithm (post-process), yet also modify parameters which are inputs to the default algorithms (pre-process)?
%     \item Is it possible to define a generic, neutral, API to mediate every significant BGP state and configuration variable, for all material vendor implmentations?
%     \item If an xBGP plugin needs to extend the core RIB entry with aadditional custom fields, can it do that?
%     \item More generally, if an xBGP plugin requires configuration, persistent state or access to external data, is that possible?
% \end{itemize}

% The answers to these questions are not all clearly in the affirmative:
% On the first point, scope of operation, it seems that the granularity of control in xBGP is very high, so that it is plausible that a pluginized BGP might behave in arbitrarilry different ways to the base case.
% However, the generic universal API issue is not so simple - xBGP does define a reasonable common core, but, unsurprisingly, well known vendor extensions, e.g. Cisco's `weight' parameter, used in Best Path calculations, are not defined in the API, and neither are well-known variations on BGP behaviour such as 'best external'.
% Regarding the third criterion - plugin runtime access to configuration,  external data, or persistent state -  only the last of these, access to plugin defined, private, local persistent state, is possible.  A workaround for configuration is provided - a private JSON file can be read by a plugin on start-up, but there is no integration with the host configuration model, nor with the host management services. 

% % As it stands, my understanding is that xBGP does not provide for a persistent
% % data store, either independent of the core RIBs, or attached to them; also,
% % that it does not have a system for adding configuration attributes, either as
% % entirely independent variables, or, more useful, and augmentations of the core
% % configuration data model.
% % If so, it may be that that is possible and practical, and a natural extension of xBGP.
% % But then , that might mean that the idea of a once-only / one-off is lost, and
% % software upgrade of xBGP also becomes itself a rolling implementation cycle.

% \textbf{Regarding the second point} -  i.e. `xBGP wants to run on core routers
% control plane' -
% there are risks with custom programmability in a core router.

% If there is a spectrum of programmability for an xBGP code fragment, between
% most limited, e.g. no persistent state, no configuration, etc etc, though to
% the opposite extreme of a more complete `general application development'
% capability, there is also an inverse spectrum of risk and overhead.

% If an xBGP plugin program is Turing complete, then it may embed recursion, or simpler,
% but effectively unbounded, programming loops.  But if the plugin is constrained to avoid then the 'programmability' is severly limited.  It seems that xBPF plugins are restricted, based on analysis of the plugin code examples.

% The worst that can happen with a badly behaved eBPF is that a single packet is
% dropped and some CPU cycles wasted.
% But, the potential impact of badly behaved xBGP is much greater than for eBPF:
% for example, suppose that an ingress xBGP program adds some custom metric to
% incoming routes to adjRIBIn,
% and then a later, complementary, xBGP program fragment overrides default best-path
% selection, based on that novel metric -
% now, if that first xBGP program were to `fail' in some cases (e.g. runs out of
% allocated execution cycles,  performs divide by zero, etc etc), and assuming
% that the resulting fail-safe action is `no action' - then
% some routes will be installed in adjRIBIn \emph{with} the metric, and others
% \emph{without} it, or with some default value.
% A conseqqunce of such failure, the routes which `break' in the first xBGP stage will be either unfairly
% penalised in the best-path process, or unfairly boosted, with the ultimate outcome being unintendeded routing, and no simple way to diagnose it, or to fix it.
% Perhaps even more insidious - suppose that the first stage program does not
% crash, but it is just buggy.... - now, there will not even be error log events from the xBGP engine,
% as clues to the root cause of a routing problem.

% Another related problem: routers run for very long periods of time - months, possibly even years.
% Routes, once installed do not change and are not re-evaluated.
% At system level - not just router level -  the comparability of e.g. local
% preference, depends on the fact that these rules never change, and so local
% preference over an entire AS is a universal property.
% But, if custom algorithms are being created, updated and regularly rolled out
% across a network, this certainty will no longer apply.

% When it comes to managability at scale, how should an AS with, say, 100 Border Routers proceed with an update to custom xBGP programs?

% Will it be safe if some routers are running an earlier version of xBGP programs?

% How can it be tested?

% How can a change be rolled back?

% It may be that the usecase for xBGP is in some sense `trivial', so that these
% existential questions seem not to apply - but, what code analysis tool can give
% that reassurance?  But, if the usecase is not highly important, then how can the risk of this change be justified?

% \footnote{these are exactly the concerns for which the Erlang/OTP system is engineered, with explicit provision for in-service upgrade}

% What happens if an xBGP program which is reasonably expected to only trigger on
% (say), customer routes, and therefore can be allowed to take a little longer to
% complete, is, after some upgrade, mistakenly allowed to run on all peers.

% Probably the only safe course of action is to have some safety breaker-switch
% which disables ALL of the xBGP programs.

% But, suppose that by then, some essential security code is written using xBGP,
% and the previous safety rails removed?

% So, the safety conscious operator decides to keep both old (route map) and new
% (xBGP) safety systems - and then discovers some horrible conflict between
% them.....

% If it always seemed unlikely that network operators or cloud-providers would
% write their own P4 programs to run on their ToR switch/routers., perhaps it it
% is unlikely that many network operators will write their own xBGP.
% But, perhaps the \emph{Vendors} might rather like a faster way of releasing new
% features....

% Regarding the last point on Implementation approach  - `Clean Slate' versus
% 'extend existing open source BGPs' -
% I'm impressed, to say the least, that FRR and bird were quite so amenable to
% this adaptation
% (but also a little puzzled - the change set on FRR in the github repo is not the 589
% lines mentioned in the paper, but more than 1,000 non-comment lines in new
% files, and several hundred more elsewhere).

% For context with PIR/hbgp - I did also look at adapting either BIRD or frr,
% but, partly because I wanted to make deeper changes than does xBGP, I chose not to follow that route.

% For comparison, hbgp is ~9.5k SLOC, xBGP is 20k in libxbgp and ~3k in the BIRD and frr changes.

% If the only metric were effort and complexity then hbgp wins, but the core
% premise of xBGP is that existing routers can easily be extended, so that the
% libxbgp investment is amortised over all users, and for that libxbgp or
% something as complex cannot be avoided.
% \subsection{Analysis of xBGP implementation}
% The source code for xBGP is published in github at \url{https://github.com/pluginized-protocols/xbgp_plugins, xbgp_bird , libxbgp, etc.} .

% xBGP is implemented in BIRD and FRR by adding numerous call outs to eBPF plugins.
% Under xBGP these modified routers call out to the dynamically provisioned plugins at multiple critical points in the BGP route processing execution path.
% Eigtheen different insertion points are defined, for example
% `bgp_pre_inbound_filter',
% `bgp_pre_inbound_filter',
% `bgp_local_pref_decision'
% .
% In the BIRD implementation, 14 of these call outs are actually implemented and thus available if a plugin chooses to `hook' them.  Typical plugins use only a subset of the possible hooks.

% A plugin runing xBGP/eBPF code can access canonical BGP data, e.g. the parsed contents of a BGP Update message, by calling a standard API.
% The functional, procedural part of an xBGP `plugin' is written in a restricted dialect of standard C.
% There exist in the xBGP repoistory 12 instances of plugin applications, though most are simple examples, e.g. `'hello_world', 'rib_walk'.
% The 'reference' application is `geo_tags' which implements support for a new BGP route attribute which encodes a global position coordinate, and uses the calculated distance from the encoded location to the local posistion as a decsion metric for `best path' algorithm, analogously to the way the IGP metric is used in standard BGP.  
% \subsection{Conclusion}
% xBGP is without doubt an impressive technical achievement.  However, whether it is a \textit{useful} technical achievement has to be asked.  One problem in addressing the question of the pracical value of xBGP is the lack of attention to this important question in the xBGP publicactions.


% To be succesful, xBGP would need to be implemented accross a service providers estate.  The headline agenda for xBGP is `When You Can’t Wait for the IETF and Vendors', which clearly targets the commercial router platforms, not the OpenSource implementations, for which at least proof-of-concept is available.  So we should ask how or whether commercial adoption is likely, and what might be the objections.

% Here are some objections which might be raised to the deployment of xBGP in live networks:

% \begin{itemize}
%     \item lack of integration with host management, e.g. for configuration, control and monitoring
%     \item plugins can only work through a simple, lowest-common-denominator API
%     \item for all critical plugin hooks there can only be a single provider - either the plugin handles the entire function, or the host does.  It means that the plugin must faithfully replicate the work which would be done in the host.  This requires that the libxbgp and instance specific code replicate instance specific functions, and that the plugin correctly calls the libxbgp API to maintain compatibility with the code which is replaced.
%     \item Just as the plugin may only use a core common API, rather than any more extensive host specific internal view, neither can a plugin extend the core state to support new functionality
%     \item writing a plugin requires a special restricted dialect of 'C', as well as a good understanding of the virtualised BGP implmentation which is represented by libxbgp.  It may also be rather hard to troubleshoot and debug, compared with a standard 'C' application.
%     \item verification - a router running an xBGP plugin essentially negates any confidence in the underlying QA and valiadtion process, even though it inevitably replaces core functional elements.  A 'canonical' null instance of a plugin which hooks every entry point could and should be tested, if an implmentation upstreamed xBGP as a core feature.  But this would provide no assurances once the injected code diverges from the zero-function stub that was tested upstream.
%     \item the xBGP concept 'bakes-in' the standard BGP internal architecture.  It means that more radical changes cannot be supported.
%     \item the architecture only allows for a single plugin to be active at a time.
% \end{itemize}

% The management integration issue is probably the strongest objection: it is possible to imaginge partial solutions, for example the existing standalone JSON file needed to configure a plugin could simply be enabled as an opaque configuration entry in the standard configuration file.  But, most BGP features require configuration statements which are related to other BGP domain entities, such as peers, and simply allowing a single JSON fragment to be passed to a plugin is hardly a fully flexible framework for extending router functionality.  Similarly, one could propose 'pass-through' commands which would allow a management console user to execute plugin specific actions.  However, since the plugin has no knowledge of the host configuration, the scope of the plugin 'management' agent would be rather limitedc ompared with what a native software extension could acheive.

% The purpose here is not to enumerate limitations on how an xBGP system can
% work, which might appear to compare unfavourably with another, more general,
% solution - but attempt to articulate the class of problem or solutions which xBGP can, or cannot,
% achieve, and define those functional boundaries.  But, unfortunately, if the limitation is such that only configuration-free and management-interface-free features are viable, then it hardly seems plausible that the high impact and risk of deploying this new paradigm in a large liv enetwork could be justified.
% When the challenges of the development environment, and the limitaions of 'only on active plugin', and the problem of validadtion for custom code are added into the equation, then it seems, based on the publically available information, that the principal router vendors are unlikely to take on board the xBGP proposistion. 


% \section{Analysis of xBGP: An Extensible BGP Framework}

% This section reviews xBGP, a framework designed to enhance the extensibility of the Border Gateway Protocol (BGP), as detailed primarily in \cite{Wirtgen2020}. This work emerged contemporaneously with the research presented in this thesis concerning Programmable Internet Routing (PIR).

% references

% The Case for Pluginized Routing Protocols \cite{wirtgen2019}

% xBGP: When You Can’t Wait for the IETF and Vendors \cite{Wirtgen2020}

% xBGP: Faster Innovation in Routing Protocols \cite{wirtgen2023}



% PIR was initially presented at IETF 106 in 2019 \cite{hart2019}. Subsequently, xBGP (\textit{The Case for Pluginized Routing Protocols: xBGP}) was presented by Olivier Bonaventure at IETF 109 in 2020 \cite{ietf109xbgb}. The close timing and conceptual similarities between PIR and xBGP are notable, with the xBGP paper \cite{Wirtgen2020} referencing earlier PIR publications. This convergence can be viewed as validating the underlying analysis regarding the need for enhanced BGP programmability. Further resources on xBGP, including presentations \cite{Wirtgen2019} and code, are available at \url{https://pluginized-protocols.org/xbgp/}.

% \subsection{Core Concepts and Architectural Differences from PIR}

% Three key distinctions characterise the xBGP approach compared to PIR:

% \begin{enumerate}
%     \item \textbf{Architectural Approach} xBGP posits that significant new capabilities can be introduced into BGP using an eBPF-like programming model, allowing user-written code execution within the BGP control plane.
%     \item \textbf{Deployment Strategy} The primary goal of xBGP is to integrate this programmability into existing production-grade BGP implementations via a one-time extension. This contrasts with deploying new capabilities on separate systems, suggesting plugins should run directly on active border routers managing the forwarding plane.  The example targets are FRR and BIRD, however it is clearly menat that commercial vendors should be the target, since there is no barrier to users directly modifying the open source routers.
%     \item \textbf{Implementation Method} xBGP modifies established open-source BGP implementations, whereas PIR opted for a clean-slate implementation (hbgp). The adaptation of FRR and BIRD for xBGP involved significant code changes (analysis suggests over 1000 non-comment lines in new files for FRR, plus modifications elsewhere, exceeding the initially reported 589 lines \cite{Wirtgen2020}).
% \end{enumerate}

% In contrast, PIR aims to avoid even one-off changes in existing core infrastructure.  An interesting line-of-investigation suggested by this project is to ask if given a single substantial enhancement to existing core routers, would the PIR proposition be materially improved?


% A further contrast between xBGP and PIR is the choice to build-from-scratch, rather than extend existing codebases.  The arguments for and against that proposition are addressed elsewhere in this thesis. \NH{reference needed}


% In comparison with xBGP, the PIR project's hbgp implementation comprises approximately 9,500 Source Lines of Code (SLOC), while. The xBGP effort involves around 20,000 SLOC in libxbgp plus approximately 3,000 SLOC for the BIRD and FRR integrations combined. While hbgp represents a smaller codebase, xBGP's premise relies on leveraging existing router platforms, necessitating the substantial libxbgp investment for broad applicability.

% \subsection{Critique of the xBGP Approach}

% xBGP allows user code injection at critical points in the BGP control-plane execution path, offering potentially broad influence. However, several critical questions arise regarding its capabilities and limitations:

% \begin{itemize}
%     \item \textbf{Plugin Interaction} Can plugins modify inputs for default algorithms (pre-processing) while also acting on their outputs (post-processing)?
%     \item \textbf{API Generality} Is a generic, vendor-neutral API feasible to expose all significant BGP state and configuration variables across diverse implementations? xBGP defines a common core but omits known vendor extensions (e.g., Cisco's `weight') and behavioural variations (e.g., `best external').
%     \item \textbf{State Extension} Can plugins augment the core RIB entry with custom fields? The current design does not appear to explicitly support extending core BGP state.
%     \item \textbf{Runtime Dependencies} Can plugins access external configuration, persistent state beyond their own local store, or external data feeds during operation? Currently, only access to plugin-private local persistent state is directly supported. Configuration is handled via a workaround (reading a private JSON file at startup), lacking integration with the host's configuration model or management services.
% \end{itemize}

% While xBGP offers fine-grained control points (18 defined insertion points, 14 implemented in the BIRD version, such as `bgp_pre_inbound_filter` and `bgp_local_pref_decision`), the limitations regarding a universal API, state extension, and integrated configuration/management pose significant challenges.
% \subsection{xBGP: Formalizing A Plugin API}

% Xpgp presents a model that formalizes and defines the scope and capability of a pluginized system using a very prescriptive and precise boundary between a plug-in and the host BGP system. This boundary is defined by the insertion signatures and the implied constraints and invariants regarding how the host activates the plugin, and populates and consumes the API-defined state values. In contrast to this highly functional operational runtime interface, there is no corresponding management plane interface, except for a very basic, isolated, static configuration file.

% \paragraph{Challenges and Implementation Strategy}

% An obvious potential challenge for to xBGP is the range of potentiall valuable new BGP behaviors that cannot be expressed in this system. A less obvious challenge is the range of behaviors that could be expressed in an even simpler scheme, for example, one which simply extends the capability of the user configuration to be more expressive.
% Another dimension of challenge for xBGP is its implementation strategy, and the singular benefits associated with it. xBGP is implemented in the well-known and currently fashionable eBPF architecture, more specifically using a user-space eBPF VM.  User-space eBPF is also called uBPF in xBGP documentation and source code.

% \paragraph{uBPF: Advantages and Core Features}

% uBPF has both advantages and disadvantages. The principal arguments for using it are


% \begin{itemize}
%     \item a fully independent build system - compile once, run anywhere, with complete  host-independence
%     \item x/uBPF are designed for high performance and low latency; for example, its initial and still primary application  is in Linux kernel packet processing.
%     \item isolation: eBPF isolates and protects the host from malicious or unintended rogue code. In the mainline kernel, eBPF enforces complexity limits very strictly. eBPF code cannot have knowledge of host-specific internal structures.
% \end{itemize}


% All three of these design goals for BPF are applicable to some degree to xBGP. For example, high performance and bounded latency are essential, especially at selected functional points in a BGP system.

% \paragraph{Value of uBPF's Independent Build System}

% The independent build system of uBPF appears more valuable to xBGP than it does to the more conventional eBPF role of kernel plugins in Linux. This is because the requirement to have a basic compiler would not significantly burden the Linux kernel eBPF use cases, given the open nature of Linux. In fact, dynamic builds are already commonplace in Linux (e.g., the DKMS system infrastructure). However, proprietary routing platforms do not provide such tools, and in this sense, xBGP offers a specific advantage.

% \paragraph{Isolation Benefits in xBGP}

% Isolation has positive impact in the context of xBGP. It's clearly beneficial that BGP-specific code cannot access system aspects unrelated to the BGP code. Isolation serves as both a runtime protection and an architectural safeguard against undocumented reliance on host system-specific internal structures.

% \paragraph{Downsides of the uBPF Architecture?}

% What are the downsides to the uBPF architecture? The most obvious stem from the restrictions it imposes on plugin code at runtime, and secondarily from specific complexities which might impact operational or development aspects of a uBPF-based system. Do any such limitations arising from uBPF impose too severe a restriction on its utility, compared with some other alternative plug-in architecture? And what would such an alternative architecture be?

% \paragraph{uBPF Limitations: Complexity and Escape Hatches}

% Let's consider the limitations of uBPF. The first limitation is that complexity bounds may be too restrictive. Non-core functions may be unreasonably constrained, and it may even be hard to prove that the core essential functions can satisfy a complexity checker, even if they are designed well. For kernal packet eBPF, the possibility to escape this fast path, when approriate, is always available; the kernel can pass exceptional packets into another execution environment. However, there is no equivalent escape hatch for xBGP, and nor is it clear that if one existed, it would be safe, given the importance of maintaining the ordering of update messages to the integrity of a BGP system.

% \paragraph{uBPF Limitations: Isolation Alternatives and API Security}

% The isolation attribute is clearly important. The problem for xBGP and uBPF is that there are other ways to provide similar safeguards, both at runtime and compile time. The downside for xBGP and uBPF is that while user-written code may be very well contained, the safety and correctness properties of the host plugin code and libxBGP cannot benefit from alternative development methods (e.g., the Rust language) which could provide similar safeguards as the VM based isolation for user written code.

% Another related problem is that the API itself is exceedingly insecure, consisting of simple C types with many examples of pointers and fixed-length buffers where buffer lengths are provided by the user. In principle, the host substrate could attempt to perform rigorous validation on all values after every return from a uBPF callout, but that's impractical while maintaining the essential high-performance capabilities. The provided implementation does not even attempt to address this.

% \subsection{Operational Risks and Management Concerns}

% Deploying custom, potentially Turing-complete code within the control plane of core routers introduces substantial risks:

% \begin{itemize}
%     \item \textbf{Stability and Debugging} Badly behaved xBGP plugins can have far greater impact than malfunctioning eBPF programs (which might drop a packet). A failing xBGP plugin influencing route selection could lead to inconsistent states (e.g., some routes processed with a custom metric, others without) resulting in unpredictable routing behaviour that is difficult to diagnose, especially if the plugin is merely buggy rather than crashing.
%     \item \textbf{Programmability vs. Safety} Unconstrained plugins might enter infinite loops or exhibit unbounded resource consumption. While xBGP plugins appear restricted based on examples, the trade-off between capability and safety is critical. Defining and enforcing these safety constraints rigorously is essential.
%     \item \textbf{Long-Term Consistency} Routers operate for extended periods, and installed routes often remain unchanged. Standard BGP relies on stable, universally applied rules (like local preference). Introducing custom algorithms that evolve and are rolled out incrementally across a network undermines this predictability.
%     \item \textbf{Deployment and Lifecycle Management} Managing updates, testing, and rollbacks for custom xBGP code across potentially hundreds of routers presents significant operational hurdles. Ensuring safe operation during version transitions and developing adequate testing methodologies are non-trivial problems. The lack of robust mechanisms for in-service upgrades is a concern.\footnote{Systems like Erlang/OTP are explicitly designed to handle such in-service code update challenges.} What happens if a plugin intended for specific routes accidentally runs on all peers after an update? A global kill-switch for all plugins might be necessary but could disable essential functions if they too become reliant on xBGP. Co-existence with legacy mechanisms (e.g., route maps) could also lead to complex conflicts.
% \end{itemize}

% \subsection{Implementation Details and Example Application}

% The xBGP source code is available on GitHub (\url{https://github.com/pluginized-protocols/xbgp_plugins}, \url{https://github.com/pluginized-protocols/xbgp_bird}, \url{https://github.com/pluginized-protocols/libxbgp}, etc.). Plugins are written in a restricted C dialect and interact with BGP data structures (e.g., Update message contents) via a standard API provided by libxbgp.

% The repository includes several example plugins (e.g., `hello_world`, `rib_walk`). The `geo_tags` plugin serves as a reference application, implementing a new BGP attribute for geographic coordinates. It uses the distance calculated from this coordinate to the local router's position as a metric influencing the best-path selection, analogous to how IGP metrics are used in standard BGP.

% \subsection{Performance Considerations}

% Perfoamnce data is reported for xBGP in two papers: \cite{wirtgen2019} and \cite{Wirtgen2020}.
% In \cite{wirtgen2019}  the measurement cited use exaBGP as a source of route data, and reports performance data for simple single table transfers into FRR.  This experiment reports small impacts of around 5\% slowdown.

% The performance in both control and actual cases is an order of magnitude worse than expected for FRR\footnote{30 seconds for 200,000 routes reported: when the source is not the constraint, FRR can process around 800,000 routes in under 5 seconds on similar hardware, i.e. x24 faster than reported. }, but since exaBGP is known to be far slower than any of the statndard open source routers, this datapoint should be disregarded entirely.  Th eimpact of other experimental deficiencies, such as neglecting to precondition the router tables, would not be detectable in this experimental context.

% In \cite{Wirtgen2020} a brief refernce is made to performance data, but only in relative terms: the mofified code is found to run around 20\% slower than unmodified code for a plugin which re-implements Route Reflection as a plugin rather than native code.  It seems that in this experiment exaBGP is no longer used as the direct source of route data, however no absolute data is given, so that it is not possible to evaluate the soudness of the methodology.  However, it seems that onluy a single peer is used, and that the plugin is not one that is inserted into the critical 'best path' interception point.

% In conclusion, there is insufficient data reported to evaluate the real-world performance of the modified routers.  It is an interesting arae for further investigation, which would consume little effort to validate and quantify the perfeoamnce profile of the xBGP/eBPF architecture.

% \subsection{Conclusion: Practical Utility and Adoption Challenges}

% While xBGP represents a significant technical accomplishment in modifying existing BGP implementations for extensibility, its practical value and likelihood of widespread adoption face considerable obstacles, primarily stemming from operational and management concerns. The publications themselves give limited attention to addressing the practical deployment challenges.

% For xBGP to succeed, particularly in commercial environments (as implied by the slogan "When You Can’t Wait for the IETF and Vendors"), it would need deployment across an operator's entire network. Several key objections hinder this prospect:

% \begin{itemize}
%     \item \textbf{Management Integration} The lack of integration with host configuration, control, and monitoring systems is arguably the most significant barrier. Workarounds like standalone JSON files are insufficient for complex feature configuration tied to BGP peers or policies.
%     \item \textbf{API Limitations} The reliance on a lowest-common-denominator API restricts access to vendor-specific features and potentially limits the complexity of achievable extensions.
%     \item \textbf{Plugin Functionality Model} Plugins often replace entire functional blocks, requiring them to faithfully replicate host behaviour while interacting correctly through the limited API.
%     \item \textbf{State Extension Difficulty}The inability for plugins to easily extend core BGP state limits the scope of new functionalities.
%     \item \textbf{Development Complexity} Writing plugins requires expertise in a restricted C dialect and the libxbgp abstraction, potentially complicating development and debugging compared to standard application development.
%     \item \textbf{Verification and Trust} Running custom plugins fundamentally compromises the validation and trust associated with the base router software, as plugins can replace core functions. Testing custom code under all conditions is challenging.
%     \item \textbf{Architectural Rigidity} The approach inherently embeds the standard BGP internal architecture, potentially hindering more radical protocol innovations.
%     \item \textbf{Single Active Plugin} The architecture reportedly allows only one plugin to be active at a time, limiting composition of functionalities.
% \end{itemize}

% Given these challenges, particularly the management integration gap and the operational risks associated with deploying custom code in critical infrastructure, widespread adoption by commercial vendors and network operators appears unlikely, based on the currently available public information and implementation status. The potential benefits must outweigh the substantial risks and operational overhead, which seems questionable for features lacking deep configuration and management integration.

% xBGP is a technical tour-de-force, and xBGP raises important questions about how BGP systems can be improved.  Even if ultimately the core proposition of opening up the closed  ecosystem of proprietrty core router vendors is an unlikely outcome, the endeavour underlines the nature of the non-technical challenges which stand in the way of innovatinng in this space.    


\section{Analysis of xBGP: An Extensible BGP Framework}

This section analyses xBGP, a framework designed to enhance the extensibility of the Border Gateway Protocol (BGP), primarily detailed in \cite{Wirtgen2020}, with related work presented in \cite{wirtgen2019} and \cite{wirtgen2023}. The development of xBGP occurred contemporaneously with the Programmable Internet Routing (PIR) research presented in this thesis.

PIR was initially introduced at IETF 106 in 2019 \cite{hart2019}. Subsequently, Olivier Bonaventure presented xBGP (\textit{The Case for Pluginized Routing Protocols: xBGP}) at IETF 109 in 2020 \cite{ietf109xbgb}. The close timing and conceptual alignment between PIR and xBGP are noteworthy, particularly as the primary xBGP paper \cite{Wirtgen2020} cites earlier PIR publications. This convergence reinforces the analysis suggesting a need for enhanced BGP programmability. Further resources on xBGP, including presentations and code, are available at \url{https://pluginized-protocols.org/xbgp/}.

\subsection{Core Concepts and Architectural Differences from PIR}

xBGP differs from PIR in three key aspects:

\begin{enumerate}
    \item \textbf{Architectural Approach} xBGP proposes introducing significant new BGP capabilities via an eBPF-like programming model, enabling user-written code execution directly within the BGP control plane.
    \item \textbf{Deployment Strategy} xBGP aims to integrate this programmability into existing production BGP implementations (initially targeting open-source platforms like FRR and BIRD, but implicitly aiming for commercial vendor adoption) through a one-time extension. This contrasts with PIR's approach of potentially deploying new capabilities on separate systems, whereas xBGP advocates for plugins running on active border routers managing the forwarding plane.
    \item \textbf{Implementation Method} xBGP modifies established open-source BGP implementations. This required substantial code changes (analysis indicates over 1000 non-comment lines added to FRR, exceeding the 589 lines initially reported \cite{Wirtgen2020}). In contrast, PIR opted for a clean-slate implementation (\hbgp). The arguments concerning the merits of modifying existing codebases versus a clean-slate build are discussed elsewhere in this thesis. 
    %%% \NH{reference needed}
\end{enumerate}

\subsection{Critique of the xBGP Approach Capabilities}

xBGP allows user code injection at critical points within the BGP control-plane execution path. However, questions arise regarding its functional scope and limitations:

\begin{itemize}
    \item \textbf{Plugin Interaction} Can plugins perform both pre-processing (modifying inputs for default algorithms) and post-processing (acting on outputs)?
    \item \textbf{API Generality} Is a generic, vendor-neutral API feasible across diverse implementations? The xBGP API defines a common core but omits known vendor extensions (e.g., Cisco's `weight`) and specific behavioural variations (e.g., `best external`).
    \item \textbf{State Extension} Can plugins augment core RIB entries with custom fields? The current design does not appear to explicitly support extending core BGP state.
    \item \textbf{Runtime Dependencies} Can plugins access external configuration, persistent state beyond their local store, or external data feeds? Currently, only plugin-private local persistent state access is directly supported. Configuration relies on a workaround (reading a private JSON file at startup), lacking integration with the host's configuration or management systems.
\end{itemize}

Although xBGP offers fine-grained control via numerous insertion points (18 defined, 14 implemented in the BIRD version, e.g., `$bgp\_pre\_inbound\_filter$`, `$bgp\_local\_pref\_decision$`), the challenges surrounding a universal API, state extension, and integrated management persist.

\subsection{xBGP: Plugin Architecture and uBPF}

xBGP formalises a pluginized system by defining a precise boundary between plugins and the host BGP system via API insertion signatures and operational constraints. While the runtime interface is highly functional, a corresponding management plane interface is absent, except for a basic, isolated static configuration file mechanism.

\paragraph{Implementation via uBPF}
xBGP employs the user-space eBPF (uBPF) virtual machine architecture. This choice presents both advantages and potential drawbacks.

\paragraph{uBPF Advantages}
The primary arguments favouring uBPF are:
\begin{itemize}
    \item \textbf{Independent Build System} Enables compile-once, run-anywhere deployment with host independence. This is particularly valuable for proprietary routing platforms lacking native development tools, unlike open systems like Linux where dynamic builds (e.g., DKMS) are common.
    \item \textbf{Performance} eBPF/uBPF is designed for high performance and low latency, crucial for certain BGP functions, mirroring its primary use in Linux kernel packet processing.
    \item \textbf{Isolation} Provides runtime protection for the host against faulty or malicious plugin code and prevents undocumented reliance on host-specific internal structures. This is clearly beneficial for stability.
\end{itemize}

\paragraph{Potential uBPF Downsides and Challenges}
The limitations imposed by uBPF raise questions about its overall suitability compared to alternatives:
\begin{itemize}
    \item \textbf{Expressiveness vs. Restrictions} The range of valuable BGP behaviours achievable might be limited. Conversely, some behaviours might be expressible via simpler extensions to user configuration.
    \item \textbf{Complexity Constraints} uBPF's strict complexity limits, inherited from kernel eBPF, might overly restrict non-core functions or even prove challenging for core functions to satisfy. Unlike kernel eBPF, which can pass exceptional packets to other environments, xBGP lacks a similar ``escape hatch," which might in any case be unsafe, given BGP's message ordering requirements.
    \item \textbf{Isolation Alternatives} While isolation is important, other methods (e.g., using memory-safe languages like Rust for host/plugin development) could offer comparable compile-time and runtime safeguards without the overhead or limitations of a VM.
    \item \textbf{API Security} The C-based API, using pointers and user-supplied buffer lengths, presents security risks. Rigorous host-side validation after every uBPF call-out seems impractical for maintaining high performance, and the current implementation does not extensively address this.
\end{itemize}


\subsection{Operational Risks and Management Concerns}

Deploying custom, potentially Turing-complete code within the control plane of core routers introduces significant operational risks:

\begin{itemize}
    \item \textbf{Stability and Debugging} Malfunctioning xBGP plugins can cause greater disruption than faulty eBPF packet filters. A buggy plugin influencing route selection could lead to inconsistent states and unpredictable routing behaviour, which is difficult to diagnose.
    \item \textbf{Programmability vs. Safety} Unconstrained plugins pose risks of infinite loops or excessive resource consumption. Defining and enforcing strict safety constraints is critical.
    \item \textbf{Long-Term Consistency} Standard BGP relies on stable, universally applied rules. Custom algorithms evolving and deployed incrementally undermine network predictability over the long operational lifespan of routers and routes.
    \item \textbf{Deployment and Lifecycle Management} Managing updates, testing, and rollbacks for custom code across numerous routers is operationally complex. Safe in-service upgrades are challenging (lacking mechanisms found in systems like Erlang/OTP\footnote{Systems like Erlang/OTP are explicitly designed to handle such in-service code update challenges.}), and issues like accidental plugin application, the need for kill-switches, and conflicts with legacy mechanisms (e.g., route maps) arise.
\end{itemize}

\subsection{Implementation Details and Example Application}

The xBGP source code is publicly available on GitHub (e.g., \url{https://github.com/pluginized-protocols/xbgp_plugins}, \url{https://github.com/pluginized-protocols/xbgp_bird}, \url{https://github.com/pluginized-protocols/libxbgp}). Plugins are developed in a restricted C dialect and interact with BGP data structures via the libxbgp API.

Example plugins like `$hello\_world$` and `$rib\_walk$` are provided. The `$geo\_tags$` plugin serves as a reference application, demonstrating a new BGP attribute for geographic coordinates. It uses the calculated distance to the local router to influence best-path selection, akin to IGP metric usage in standard BGP.

Regarding implementation size, the PIR project's \hbgp comprises approximately 9,500 Source Lines of Code (SLOC). The xBGP effort involves roughly 20,000 SLOC in its core library (libxbgp) plus about 3,000 SLOC for integration into BIRD and FRR.\footnote{The SLOC counts given here are higher than reported in xBGP publications, but are correct for the current published versions available in github.} While \hbgp is smaller, xBGP leverages existing router platforms, necessitating the significant libxbgp investment for broader potential applicability.

\subsection{Performance Considerations}

Performance data for xBGP is reported in \cite{wirtgen2019} and \cite{Wirtgen2020}.

In \cite{wirtgen2019}, experiments using exaBGP as a data source reported small performance impacts (around 5\% slowdown) for simple table transfers into FRR. However, the reported absolute performance appears significantly lower than expected for FRR under optimal conditions\footnote{The reported 30 seconds for 200,000 routes contrasts with expectations of FRR processing $\approx$ 800,000 routes in < 5 seconds on similar hardware, suggesting a potential bottleneck (like exaBGP) or other experimental limitations.}, casting doubt on the applicability of this specific result.

In \cite{Wirtgen2020}, performance is mentioned briefly in relative terms: modified code ran approximately 20\% slower than unmodified code when re-implementing Route Reflection as a plugin. While exaBGP seems not to be the direct data source here, the lack of absolute figures and details, and the rather minimal configuration and application (e.g., single peer used, plugin not in critical 'best path' logic) makes it difficult to assess overall the methodology's soundness in dimensions of performance and scalability.

In summary, the reported data is insufficient to fully evaluate the real-world performance implications of the xBGP modifications. Further investigation would be valuable to quantify the performance profile of the xBGP/uBPF architecture.

\subsection{Conclusion: Practical Utility and Adoption Challenges}

xBGP represents a significant technical achievement in adapting existing open-source BGP implementations for extensibility. However, its practical value and prospects for widespread adoption face considerable hurdles, mainly related to operational integration and management. xBGP publications offer limited discussion on resolving these practical deployment challenges.

For xBGP to gain traction, especially in commercial settings (as suggested by the slogan "When You Can’t Wait for the IETF and Vendors"), deployment across an operator's entire network would likely be necessary. Several key challenges impede this:

\begin{itemize}
    \item \textbf{Management Integration} The lack of integration with host configuration, control, and monitoring systems is arguably the most significant barrier. Standalone configuration files are inadequate for complex features tied to specific peers or policies.
    \item \textbf{API Limitations} Relying on a lowest-common-denominator API restricts access to vendor-specific features and may limit the complexity of achievable extensions.
    \item \textbf{Plugin Functionality Model} Plugins often replace entire functional blocks, demanding faithful replication of host behaviour through a limited API.
    \item \textbf{State Extension Difficulty} The inability for plugins to easily extend core BGP state limits the scope of potential new functionalities.
    \item \textbf{Development Complexity} Plugin development requires expertise in restricted C and the libxbgp abstraction, potentially increasing complexity compared to standard application development.
    \item \textbf{Verification and Trust} Running custom plugins undermines the validation and trust associated with the base router software, as plugins can replace core logic. Comprehensive testing is difficult.
    \item \textbf{Architectural Rigidity} The approach inherently embeds the standard BGP internal architecture, potentially hindering more radical protocol innovations.
    \item \textbf{Single Active Plugin Limitation} The architecture permits only one active plugin at a time, for the common cases that the plugin hooks a function such as `best path selection', preventing the deployment of multiple extensions.
\end{itemize}

As concrete examples of harder use-cases, the possibility of implementing two actual PIR capabilities in xBGP might be considered: e.g. RFC 7911 ADDPATH and PIR's custom BGP behaviour `route poisoning', used in the `BGP Protection' application.

\begin{itemize}
    \item\textbf{RFC 7911 ADDPATH}

    This is simply the implementation of the RFC, which is widely supported in current proprietary and open-source routers.
    
    ADDPATH is avowedly challenging: it modifies the underlying BGP message format for carrying route prefixes.

    Additionally, ADDPATH extends the BGP LocRib by adding 32 bit route identifiers to every stored route, and propagates these identifiers in Update messages exchanged with ADDPATH capable peers.

    Another problem for xBGP with ADDPATH is that it is typically enabled,  by configuration, selectively on a peer-by-peer basis.  Without an integration with the host configuration model, such fine-grained control would not be feasible.
    
    \item  \textbf{BGP Protection}  BGP Protection is a PIR specific application, which builds on an optionally ADDPATH enabled BGP speaker, storing an additional field in the LocRib.  BGP Protection selectively advertises alternate `non-best-path-routes' to a subset of IBGP peers when actively managing `'poisoned' routes.  To safeguard routing integrity, the rules around route withdrawals are handled differently than any normal BGP system would.  The feature itself is rather simple in terms of 'lines-of-code', but it requires extensions to the core API definitions of routes which amount to more than a simple 'additional field', and would be an exclusive plugin because it hooks the `best path' call back.  As such, the simple version of BGP Protection which is unaware of ADDPATH could not be deployed in an otherwise ADDPATH aware router, but a router enhanced by another plugin to support ADDPATH could not deploy the simple version of BGP Protection.
    \item  \textbf{`Integrated PIR', } as described in Conclusions at \ref{sec:Integrated PIR}, seems even less feasible a target, requiring as it does elements of both \textbf{RFC 7911 ADDPATH} and  \textbf{BGP Protection}, and also a new BGP Capability which is negotiated at session establishment, and also a capability to dynamically vary the additional routes advertised using BGP ADDPATH.
\end{itemize}

Given these obstacles, particularly the management integration gap and operational risks, widespread adoption by commercial vendors and network operators seems unlikely based on currently available information. The potential benefits of extensibility must outweigh these substantial risks and operational overheads, a balance that appears questionable without deeper integration into router management ecosystems.

Despite these challenges, xBGP is a technical accomplishment that prompts important questions about improving BGP systems. Even if modifying proprietary core routers remains difficult, the project highlights the non-technical barriers to innovation in internet routing infrastructure.

\section {shorter summaries of more recent articles (2025 perspective)}

% \cite{shao2021} {Policy-rich interdomain routing with local coordination}
% \NH{quite interesting, need to reference this in the BGP chapter}


  
\paragraph{Towards AI/ML-Driven Network Traffic Engineering}
In \cite{alam2024}, the wealth of published work on topics which could drive a more flexible routing system is articulated.  Not all of the work is directly related to the IDR problem space, but many papers are. 

\paragraph{`Can We Save The Public Internet?' and `Revitalizing the public internet by making it extensible'}

\begin{itemize}
    \item \textbf{`Can We Save The Public Internet?'}: \fullcite{blumenthal2024}
    \item \textbf{`Revitalizing the public internet by making it extensible'}: \fullcite{Balakrishnan2021}
\end{itemize}

Two of very few outward looking papers which call for attention to changes in Internet structure.  Polemical rather than technical, but raising important issues which are relevant to more technical work, which sets as goals `improving (Inter)-network service'. 


% Achieving sub-50 milliseconds recovery upon BGP peering link failures \cite{bonaventure2005} \NH{needed also in BGP chapter i think}

% \cite{gigis2021} Seven years in the life of Hypergiants' off-nets

\paragraph{BGP anomaly detection as a group dynamics problem}
\fullcite{scott2025} 
% scott2025  

presents  \textit{the first ever application of Multidimensional Recurrence Quantification Analysis (MdRQA) to any computer system, offering a robust BGP anomaly detection technique that identifies anomalies earlier than traditional single-AS observable methods}.

An up-to-date complementary technique for identifying core internet BGP threats, illustrating once more the need for BGP systems which can take action in response to the ever more sophisticated threat detection capabilities. 

\paragraph{Performance-Driven Internet Path Selection}
 \fullcite{apostolaki2021}

 This is an interesting, complex and well executed project, however ultimately futile.
 It combines real-time traffic monitoring with a BGP route override capability to implement load balancing in a stub AS under certain very specific conditions.  \textit{Performance-Driven Internet Path Selection} requires P4 hardware platform at all points of application, both control and monitoring.  It serves very well as an exposition of the multiple challenges in applying novel techniques in existing networks.  The paper is exceptional in the manner in which these limitations are accurately identified.

 It would be nice to see a conclusion to the paper which frankly  articulates the impractical nature of the project as a step towards improving \textit{real} network performance, and thus illuminate how challenging the problem space is, even though it is clear on careful reading that the authors are fully aware of the point.


% \cite{Ferguson2021} {Orion: Google{\textquoteright}s {Software-Defined} Networking Control Plane}, This is relevant because of reference to `RAVEN' - google BGP - but this paper only points back to Espresso (\cite{Yap2017})


% Open/R?

% https://github.com/facebook/openr



% Not recent, but strangely missing - \cite{Voellmy2009} - {Nettle: A Language for Configuring Routing Networks}
\section{Summary and Conclusions}
The related work described falls in to two broad classes: recent and related, but with somewhat different objectives or application areas to the present thesis;
and older work, albeit with closer correspondence in purpose and context to this thesis.
With two notable exceptions, none of the cited work \emph{successfully} addresses the issues of transition from academic context and proof-of-concept implementations into commercial networks.
The exceptions are the contributions from large network operators themselves, and it is that work which this thesis contribution most clearly follows and extends,
albeit as an early stage prospectus rather than a \textit{post hoc} report.
If this thesis is critical of other work, it is in the expectation of the same level of critique of this work:
for example, the proposition that a solution design when evaluated for performance should be evaluated according to \emph{realistic parameters} derived from current networks,
and a solution design which is intended to provide resilience should be itself resilient against known failure modes in its internal structure,
and that designs which add new capabilities should take care to preserve the existing ones.
\\
Trivial counter examples of this are the SDX's: which abolish the IXP user specific BGP feeds (views) which are the standard operational mode for IXP members; their abuse of the ARP protocol as a route dissemination system, when it provides no guarantees of delivery of critical routing information; and the absence of analysis or response to the operational impact of large bursts of routing updates, which it appears would lead to long periods of service downtime, possibly unrecoverable if the ARP mechanism fails under stress.
\\
The greatest scepticism is reserved for the work under the banner of SDX: but this work is closest to that in many respects, and the concerns raised in this chapter have had direct impact on the approach in the remainder of this thesis.
