\chapter{On BGP}
There exist many books and publications on BGP, with a variety of focus:
\begin{itemize}
    \item BGP as a protocol - stability, performance, and simply `how it works'
    \item BGP applications - core internet routing (IDR), data-centre applications, customer (MPLS-/L3)VPN, EVPN and layer 2 VPNs and scaling,
    \item internet structure - peering, `flattening', security, economics, topology evolution, resilience
    \item implementation
\end{itemize}
For many purposes it's possible to treat BGP routers simply as components that exchange abstracted route objects, objects with the well known properties of AS paths, local preference, BGP communities etc., put passing over any detailed consideration of the dynamics of coordinating simultaneous high volumes of input and output messages, with multiple peers, and the necessary rules which ensure consistent and convergent behaviour.
Its also possible to study BGP systems in great depth, without understanding or considering the peculiar and different behaviour of BGP as an AS \textit{internal} protocol, its interaction with IGPs - other internal routing protocols, operating concurrently in the same AS, and the mechanisms employed within an AS to implement the essential distinctive behaviours towards `customers', `peers' and `providers'.    Another complementary domain is the internal administration of BGP routers within an AS  in order to achieve desired outcomes for traffic flows \textit{with other ASes}.  All of these domains fall loosely into the category of what is sometime called `BGP' policy - but none of them relate to the challenges faced by an implementer of BGP.  Fortunately, the implementer need understand nothing of these issues and problems in order to build not only a passable BGP, but actually a BGP which is as good as or `better', than any existing BGP.
But, the bridge between the `eyes-down' world of the BGP implementer and the `eyes-up, looking outward' perspective of the network architect or manager is the murky world of the `BGP policy engine' - the part of a BGP system in which every implementation differs, which requires the implementer to define some form of `programming language', or DSL - is the subject of the practical work of this thesis, and is also one of just two  areas which distinguishes BGP implementations from each other, and offers scope for innovation, differentiation, and, if done wrong, catastrophic network failures.

In this thesis, the presentation of BGP is oriented primarily towards the eyes-down implementation aspects, relevant to the work presented, and secondly as an overview of operational principle which serves as a background to the applications developed, and outlines ways in which the conventional `policy engine' limits the scope of control and flexibility.  The last aspect presented is an exposition of the beautiful way in which BGP distributes decision making process over  an entire AS, enabling huge scalability and resilience, but which also makes the concept of creating a central point of control seemingly impossible without losing the benefits of the distributed architecture.
